# Codebase Snapshot

Generated: 2025-01-22 05:52:28
Source: /Users/jamesyoungerdds/Dropbox/TempStarsCoding/Staging-WIP/AICodeReview

## Table of Contents

- .cursorrules
- TestSteps.md
- README.md
- treeViewMigration.md
- package.json
- tsconfig.json
- nextSteps.md
- public/index.html
- public/manifest.json
- src/index.tsx
- src/App.tsx
- src/types/global.d.ts
- src/types/index.ts
- src/references/designCodingStandards.md
- src/references/businessContext.md
- src/references/databaseSchema.md
- src/server/proxy.js
- src/server/package.json
- src/utils/helpers.ts
- src/utils/storage.ts
- src/components/FileTree.tsx
- src/components/ReviewWizard.tsx
- src/components/Steps/FileSelectionStep.tsx
- src/components/Steps/GitHubPRStep.tsx
- src/components/Steps/Step6ReviewResults.tsx
- src/components/Steps/JiraTicketStep.tsx
- src/components/Steps/AdditionalFilesStep.tsx
- src/components/Steps/ReviewSubmissionStep.tsx
- src/prompts/systemPrompt.js
- src/services/JiraService.ts
- src/services/GitHubService.ts
- src/services/LocalFileService.ts
- src/services/FileService.ts
- src/services/LLMService.ts

---

## File: .cursorrules (Cursorrules)

### This file describes the overall scope and intent of the codebase
```text
1. Project Overview
Goal: Assist a beginner developer to build a web application that automates and simplifies AI-based code reviews. The system integrates with Jira and GitHub, gathers relevant code/files automatically, and sends a comprehensive prompt to an LLM.  

Because you are working with a beginner code, always be explicit and detailed about which files to change, how to change them, and where exactly the files are located.

The project is a multi-step wizard:

# STEP 1 # 

Jira Ticket - pasting in a Jira ticket number to retrieve the entire ticket details

# STEP 2 # 

GitHub PR - pasting in a GitHub pull request number to retrieve the pull request details, diffs, and changed files - showing the code files that were worked on and changes.

# STEP 3 # 

Selective File Concatenation - using a checkbox-based file directory tree navigation UI to navigate locally and select all the files that are relevant to the ticket and pull request. 
1.  Allow the user to enter a root directory path as a starting point
2.  Display the full file directory tree starting from the root directory, with checkboxes beside each file and subdirectory
3.  Allow selective checking of the boxes to include in the concatenation
4.  When checking the box beside a folder, it should include everything in that folder, including sub-folders and files
5. When "Next" is clicked, the system then concatenates all the selected files, according to the logic rules outlined in the program
6.  It should have an easy-to-use UI

Note: We're not concatentating from the repos, we're selecting local files and folders to concatenate into the markdown file.  So the concatention is a local tree navigation with checkboxes and doesn't require the github call.

So for example:

Pull Request #23245 and Pull Request #2560 (and selecting the relevant repos) would pull in the diffs and those files.  

But in Step 3 of the concatenation, the deveoper will go through and manually select not just the files that were worked on, but any other files and folders that would be contextually relevant  for the code review.

So the developer might make 3 changes on the front end to the sign-up flow, but then select the entire api folder to send along for additional context in the analysis. 

# STEP 4 # 

Select Additional Files needed for context - such as coding standards, DB schema, or any references.

# STEP 5 # 

Submit Review - submitting all the data to the LLM for review generation.  The submitted api call to the LLM includes a system prompt which instructs the LLM, along with the Jira ticket details, acceptance criteria, linked epics, pull request details, diffs, changed files, the concatenated file, and any additional files needed for context.

# STEP 6 # 

Code review is returned to the user from the LLM.

# Key Objectives #

Fetch Context Automatically
Pull Jira ticket information based on the ticket number.
Pull GitHub pull request information based on the pull request number.
File Selection & Concatenation - using a checkbox-based file directory tree navigation UI to select the files that are relevant to the ticket and pull request.  Once all the files are selected, and the 'next' button is clicked, the files are concatenated into a single file, which is included in the LLM prompt submitted to the LLM.

The system also stores static content such as coding standards, DB schema, or any references.  These optional context files are listed in Step 4, and if checked, they are included in the LLM prompt submitted to the LLM.

2. Tech Stack

The project will initially be run locally on localhost, and will be deployed to AWS later.  The project will be React/Typescript based and use the Google Gemini LLM API.

Authentication & Authorization

GitHub api authentication
Jira api authentication
Google Gemini LLM API authentication

# Psuedo-Code for LLM Prompt Generation #

=====start pseudo-prompt=====

You are an expert-level code reviewer for TempStars, a web and mobile based two-sided marketplace platform that connects dental offices with dental professionals for temping and hiring.

ROLE AND OBJECTIVE:
- You are tasked with providing comprehensive, actionable code reviews
- Your analysis should focus on code quality, security, performance, and alignment with business requirements
- You should identify potential bugs, edge cases, and areas for optimization
- You must ensure the code aligns with the provided database schema and coding standards.

// {{++insert other role and task instructions and context++}} //

Here is the Jira ticket information related to this task:

${jiraTicketInfo}

And here is the pull request information as related to this task:

${pullRequestInfo}

And this is a giant concatenated file that contains all files related to the work on this pull request, included additional files for context:

${concatenatedFileContents}

And this is additional context you'll need to know:

This is the database schema: ${dbSchema}

And these are our coding and design standards: ${codingDesignStandards}

With all this information, provide:

REVIEW GUIDELINES:
1. Code Quality:
   - Identify any code smells or anti-patterns
   - Check for proper error handling
   - Verify proper typing and null checks
   - Assess code organization and modularity
   - Review naming conventions and code clarity

2. Database Considerations:
   - Verify proper use of database schema
   - Check for potential SQL injection vulnerabilities
   - Review query performance and optimization
   - Ensure proper handling of relationships between tables

3. Security:
   - Check for security vulnerabilities
   - Verify proper authentication/authorization
   - Review data validation and sanitization
   - Assess handling of sensitive information

4. Performance:
   - Identify potential performance bottlenecks
   - Review API call efficiency
   - Check for unnecessary re-renders in React components
   - Assess memory usage and potential leaks

5. Business Logic:
   - Verify implementation matches acceptance criteria
   - Check for proper handling of edge cases
   - Ensure business rules are correctly implemented
   - Verify proper error messaging for users

Please provide your review in the following structure:

1. SUMMARY
Brief overview of the changes and their impact

2. CRITICAL ISSUES
Any blocking issues that must be addressed

3. RECOMMENDATIONS
Suggested improvements categorized by:
- Security
- Performance
- Code Quality
- Business Logic
- Testing

4. POSITIVE HIGHLIGHTS
Well-implemented aspects of the code

5. DETAILED BREAKDOWN
File-by-file analysis of significant changes

Remember to be thorough but constructive in your feedback, providing specific examples and suggested solutions where applicable.

=====end pseudo-prompt=====

// future idea: once all the information is gathere, there's a 'review submission' button that shows the contents of the entire prompt that will be sent to the LLM api call.  It counts the number of tokens in the total prompt and allows the user to select the LLM model to submit to.  Large prompts would need Gemini, but smaller prompts could use the o1 model.


```

---

## File: TestSteps.md

```text
I want to implement a way to test each step.  What I'm picturing is creating individutal files that, when run, test each step individually:

JiraFetch.js:  When this is run, it only fetchs and returns all the information of a hard-coded Jira ticket #

PullRequestFetch.js:  When this is run, it only fetches and returns all the information related to a specific hard-coded PR #

FileConcatenate.js:  When run, this opens the interface for entering the path of the starting directory, fetches the directory tree for that starting folder with checkboxes.  Selecting files and folders and hitting "Submit" then concatenates the files into one long text file

SubmitReview.js:  When run, it makes the api call to Gemini with mock data to review and returns the analysis.

By creating this ability to individually test each step in the wizard workflow, we can hone in on issues and bugs more easily.

Below is a step-by-step guide on creating four individual test scripts (JiraFetch.js, PullRequestFetch.js, FileConcatenate.js, and SubmitReview.js) so you can test each “wizard step” independently. 

In doing so, you’ll reuse much of the existing logic (e.g., your services, local file selection, LLM submission) without needing the entire UI or multi-step workflow running.

General Approach

Folder Structure

Place these test scripts in a convenient location—for example, a new scripts/ or tests/manual/ folder in your project’s root.

Each script will be run with Node (e.g. node JiraFetch.js) and will:
Import the relevant service or function from your existing code.
Hard-code or ask for user input to replicate each step’s functionality.
Log (or display) the results in the terminal.
Environment Variables

Ensure your .env or environment variables for JIRA, GitHub, and the Gemini LLM are set in your Node environment. That means the same environment variables you use in your code (like REACT_APP_JIRA_API_TOKEN, etc.) must be accessible when running node .... If they’re not, either rename them or set them manually for these scripts.
TypeScript vs. JavaScript

If your existing code is in TypeScript, you have two main options for these scripts:
Write them in plain JavaScript (.js) and compile them with Node (you may need ts-node or a separate build script if you want them in TypeScript).
Write them as .ts scripts and run them with ts-node.
For simplicity, this guide assumes plain .js scripts. If you want TypeScript, just adapt accordingly (e.g. import ... from ...; with TypeScript and run via ts-node myScript.ts).

1. JiraFetch.js
Purpose
Test Step 1 logic alone—fetching a Jira ticket by a hard-coded issue number and printing the results.

High-Level Steps
Import your getTicketDetails function from JiraService.ts.
Read any needed environment variables (like process.env.REACT_APP_JIRA_API_URL).
Set a hard-coded ticket number (e.g., PROJ-123) or prompt the user in the console for a ticket number if you want interactive testing.
Call getTicketDetails(ticketNumber).
Log or output the result.
Detailed Example

// scripts/JiraFetch.js
require('dotenv').config();  // so we can read from .env
const path = require('path');

// Because your service is in TypeScript, either transpile it or use ts-node/require it in:
const { getTicketDetails } = require('../src/services/JiraService'); // adjust path if needed

(async function testJiraFetch() {
  try {
    const hardcodedTicketNumber = 'PROJ-123'; // example
    console.log(`Fetching Jira Ticket: ${hardcodedTicketNumber} ...`);

    const result = await getTicketDetails(hardcodedTicketNumber);
    console.log('Jira Ticket Fetch Result:', JSON.stringify(result, null, 2));
  } catch (error) {
    console.error('Error fetching Jira ticket:', error);
  }
})();
How to run:

cd scripts
node JiraFetch.js
If everything is set up properly, you’ll see the fetched Jira ticket info or an error if environment variables aren’t correct.

2. PullRequestFetch.js
Purpose
Test Step 2 logic alone—fetching GitHub PR details for a specified PR number.

High-Level Steps
Import your getPullRequestDetails from GitHubService.ts.
Hard-code or prompt a GitHub PR number.
Call getPullRequestDetails(prNumber, owner, repo).
Log the results.
Detailed Example

// scripts/PullRequestFetch.js
require('dotenv').config();
const { getPullRequestDetails } = require('../src/services/GitHubService'); // adjust path

(async function testPullRequestFetch() {
  try {
    const prNumber = 42;  // example
    const owner = 'drjyounger';  // example from your code
    const repo = 'tempstars-app';  // or 'tempstars-api'
    
    console.log(`Fetching PR #${prNumber} from ${owner}/${repo} ...`);
    
    const result = await getPullRequestDetails(prNumber, owner, repo);
    console.log('Pull Request Fetch Result:', JSON.stringify(result, null, 2));
  } catch (error) {
    console.error('Error fetching PR:', error);
  }
})();
How to run:

node PullRequestFetch.js
You should see the PR title, description, and changed files if everything is correct.

3. FileConcatenate.js
Purpose
Test Step 3 logic alone—loading a local directory tree, letting you select files/folders, and then concatenating them into one file.

Important: Because your wizard step is built with React, you have to decide how to replicate the UI’s functionality. The minimal approach is to do everything in the terminal:

Prompt for a root directory path (or hard-code it).
Use your local file reading service (like readLocalDirectory or direct calls to /api/local/directory) to get the tree.
Render or log it in the terminal with some basic “selection” approach or simply pick a set of known files for this test.
Call your existing server endpoint (/api/concatenate-files) or the same underlying logic (concatenateFiles from FileService.ts).
Print the final concatenated text.
Detailed Example (Simple Approach)

// scripts/FileConcatenate.js
require('dotenv').config();
const inquirer = require('inquirer'); 
// inquirer (npm i inquirer) allows you to ask questions in CLI

const { getDirectoryTree, concatenateFiles } = require('../src/services/FileService');

(async function testFileConcatenate() {
  try {
    // 1) Get rootPath from user input, or hard-code
    const { rootPath } = await inquirer.prompt([
      {
        type: 'input',
        name: 'rootPath',
        message: 'Enter the root directory path for test (e.g. /Users/you/YourProject):',
        default: process.cwd()  // just the current directory as default
      }
    ]);

    console.log('Fetching directory tree. This may take a moment...');
    
    // 2) Retrieve directory tree
    const dirTree = await getDirectoryTree(rootPath);
    console.log('Directory Tree (top level):', JSON.stringify(dirTree, null, 2));

    // For a real test, you might recursively list subfolders. 
    // But for simplicity, let's pick some known files or ask user again:
    const { filePaths } = await inquirer.prompt([
      {
        type: 'input',
        name: 'filePaths',
        message: 'Enter a comma-separated list of file paths to concatenate (relative or absolute):'
      }
    ]);

    // Convert user input into array
    const selectedFiles = filePaths.split(',').map(f => f.trim());

    // 3) Use the same logic as the server to get a big concatenated output
    console.log('Concatenating selected files...');
    const response = await concatenateFiles(selectedFiles, 'TestPRNumber'); 
    // second param is the PR number, though you might not use it

    if (response.success) {
      console.log('\n----- Concatenated Output Start -----\n');
      console.log(response.data);
      console.log('\n----- Concatenated Output End -----\n');
    } else {
      console.error('Failed to concatenate files:', response.error);
    }

  } catch (error) {
    console.error('Error in FileConcatenate script:', error);
  }
})();
How to run:

node FileConcatenate.js
You’ll see a prompt for a root path and then a second prompt for file paths to concatenate. This is a “basic CLI approach,” but it demonstrates how you’d test the logic without the React UI.

4. SubmitReview.js
Purpose
Test Step 5 logic alone—submitting data to the LLM (Gemini) endpoint to get back a code review.

Since your final wizard step calls /api/generate-review, you can:

Use the same code your final step uses (generateCodeReview from LLMService.ts).
Pass mock JiraTicket, mock GitHubPR, and a fake concatenated file, or real content from prior steps.
Log the LLM’s response.
Detailed Example

// scripts/SubmitReview.js
require('dotenv').config();
const { generateCodeReview } = require('../src/services/LLMService');

(async function testSubmitReview() {
  try {
    // Mock data or partial real data from your actual ticket & PR
    const mockJiraTicket = {
      key: 'PROJ-999',
      summary: 'Test summary',
      description: 'Testing LLM generation without the UI...',
      acceptanceCriteria: 'Demo acceptance criteria',
      linkedEpics: []
    };

    const mockGitHubPR = {
      title: 'Test PR Title',
      description: 'Description of changes for testing LLM code review logic',
      number: 123,
      repo: { owner: 'drjyounger', name: 'tempstars-app' },
      changedFiles: []
    };

    // Use some short text for testing
    const mockConcatenatedFiles = `
# File: example.js
\`\`\`js
console.log('Hello from the test script');
\`\`\`
`;

    const mockReferenceFiles = [
      'Some example context: Database Schema or coding standards text here...'
    ];

    console.log('Sending data to the LLM API...');
    const result = await generateCodeReview({
      jiraTicket: mockJiraTicket,
      githubPR: mockGitHubPR,
      concatenatedFiles: mockConcatenatedFiles,
      referenceFiles: mockReferenceFiles
    });

    if (result.success) {
      console.log('\nLLM Review Response:\n', result.data);
    } else {
      console.error('LLM Review Error:', result.error);
    }
  } catch (error) {
    console.error('Error in SubmitReview:', error);
  }
})();
How to run:

node SubmitReview.js
If your Gemini API environment variables are set and valid, you should see a review response. If not, you’ll get an error from Gemini or from your script.

Additional Tips
Separate .env for Scripts: If your React environment variables have the prefix REACT_APP_, you may rename or set them in .env so that your Node scripts see them as process.env.REACT_APP_....
Directory Paths: Watch out for relative paths (../src/services/...) since your scripts might live in a separate folder. Adjust accordingly.
Error Handling: You might see unhelpful error messages if your environment variables or tokens are missing. Add console logs to confirm.
Conclusion
By creating these four test scripts, you can run each step in isolation:

node JiraFetch.js → pulls a Jira ticket
node PullRequestFetch.js → pulls a GitHub PR
node FileConcatenate.js → fetches local directory structure & concatenates chosen files
node SubmitReview.js → hits your LLM service with mock or real data
This setup will help debug more quickly without going through the entire React-based wizard. Just be mindful of environment variable consistency and the correct import paths to your existing service functions. Once these are operational, you’ll know each piece is stable—making the final wizard flow more reliable.
```

---

## File: README.md

```text

```

---

## File: treeViewMigration.md

```text
Migration from v6 to v7
This guide describes the changes needed to migrate the Tree View from v6 to v7.
ads via Carbon
Start Your Web Dev Career! Learn JavaScript, CSS & more with Frontend Masters today!
ads via Carbon

Introduction

This is a reference guide for upgrading @mui/x-tree-view from v6 to v7. To read more about the changes from the new major, check out the blog post about the release of MUI X v7.

Start using the new release

In package.json, change the version of the Tree View package to ^7.0.0.

-"@mui/x-tree-view": "^6.0.0",
+"@mui/x-tree-view": "^7.0.0",

Copy
Update @mui/material package

To have the option of using the latest API from @mui/material, the package peer dependency version has been updated to ^5.15.14. It is a change in minor version only, so it should not cause any breaking changes. Please update your @mui/material package to this or a newer version.

Run codemods

The preset-safe codemod will automatically adjust the bulk of your code to account for breaking changes in v7. You can run v7.0.0/tree-view/preset-safe targeting only Tree View or v7.0.0/preset-safe to target other MUI X components like the Data Grid as well.

You can either run it on a specific file, folder, or your entire codebase when choosing the <path> argument.

// Tree View specific
npx @mui/x-codemod@latest v7.0.0/tree-view/preset-safe <path>

// Target other MUI X components as well
npx @mui/x-codemod@latest v7.0.0/preset-safe <path>

Copy
If you want to run the codemods one by one, check out the codemods included in the preset-safe codemod for the Tree View for more details.

Breaking changes that are handled by preset-safe codemod are denoted by a ✅ emoji in the table of contents on the right side of the screen or next to the specific point that is handled by it.

If you have already applied the v7.0.0/tree-view/preset-safe (or v7.0.0/preset-safe) codemod, then you should not need to take any further action on these items. If there's a specific part of the breaking change that is not part of the codemod or needs some manual work, it will be listed in the end of each section.

All other changes must be handled manually.

Not all use cases are covered by codemods. In some scenarios, like props spreading, cross-file dependencies, etc., the changes are not properly identified and therefore must be handled manually.

For example, if a codemod tries to rename a prop, but this prop is hidden with the spread operator, it won't be transformed as expected.

<RichTreeView {...newProps} />

Copy
After running the codemods, make sure to test your application and that you don't have any console errors.

Feel free to open an issue for support if you need help to proceed with your migration.

Breaking changes

Since v7 is a major release, it contains changes that affect the public API. These changes were done for consistency, improved stability and to make room for new features.

Drop the legacy bundle

The support for IE 11 has been removed from all MUI X packages. The legacy bundle that used to support old browsers like IE 11 is no longer included.

If you need support for IE 11, you will need to keep using the latest version of the v6 release.

Drop Webpack 4 support

Dropping old browsers support also means that we no longer transpile some features that are natively supported by modern browsers – like Nullish Coalescing and Optional Chaining.

These features are not supported by Webpack 4, so if you are using Webpack 4, you will need to transpile these features yourself or upgrade to Webpack 5.

Here is an example of how you can transpile these features on Webpack 4 using the @babel/preset-env preset:

 // webpack.config.js

 module.exports = (env) => ({
   // ...
   module: {
     rules: [
       {
         test: /\.[jt]sx?$/,
-        exclude: /node_modules/,
+        exclude: [
+          {
+            test: path.resolve(__dirname, 'node_modules'),
+            exclude: [path.resolve(__dirname, 'node_modules/@mui/x-tree-view')],
+          },
+        ],
       },
     ],
   },
 });

Copy
✅ Rename nodeId to itemId

The required nodeId prop used by the Tree Item has been renamed to itemId for consistency:

 <TreeView>
-  <TreeItem label="Item 1" nodeId="one">
+  <TreeItem label="Item 1" itemId="one">
 </TreeView>

Copy
The same change has been applied to the ContentComponent prop:

 const CustomContent = React.forwardRef((props, ref) => {
-  const id = props.nodeId;
+  const id = props.itemId;
   // Render some UI
 });

 function App() {
   return (
     <SimpleTreeView>
       <TreeItem ContentComponent={CustomContent} />
     </SimpleTreeView>
   )
 }

Copy
✅ Use Simple Tree View instead of Tree View

The <TreeView /> component has been deprecated and will be removed in the next major. You can start replacing it with the new <SimpleTreeView /> component which has exactly the same API:

-import { TreeView } from '@mui/x-tree-view';
+import { SimpleTreeView } from '@mui/x-tree-view';

-import { TreeView } from '@mui/x-tree-view/TreeView';
+import { SimpleTreeView } from '@mui/x-tree-view/SimpleTreeView';

   return (
-    <TreeView>
+    <SimpleTreeView>
       <TreeItem itemId="1" label="First item" />
-    </TreeView>
+    </SimpleTreeView>
   );

Copy
If you were using theme augmentation, you will also need to migrate it:

 const theme = createTheme({
   components: {
-    MuiTreeView: {
+    MuiSimpleTreeView: {
       styleOverrides: {
         root: {
           opacity: 0.5,
         },
       },
     },
   },
 });

Copy
If you were using the treeViewClasses object, you can replace it with the new simpleTreeViewClasses object:

 import { treeViewClasses } from '@mui/x-tree-view/TreeView';
 import { simpleTreeViewClasses } from '@mui/x-tree-view/SimpleTreeView';

-const rootClass = treeViewClasses.root;
+const rootClass = simpleTreeViewClasses.root;

Copy
Use slots to define the item icons

Define
expandIcon
The icon used to expand the children of an item (rendered when this item is collapsed) is now defined as a slot both on the <TreeView /> and the <TreeItem /> components.

If you were using the ChevronRight icon from @mui/icons-material, you can stop passing it to your component because it is now the default value:

-import ChevronRightIcon from '@mui/icons-material/ChevronRight';

 <SimpleTreeView
-  defaultExpandIcon={<ChevronRightIcon />}
 >
   {items}
 </SimpleTreeView>

Copy
If you were passing another icon to your Tree View component, you need to use the new expandIcon slot on this component:

 <SimpleTreeView
-  defaultExpandIcon={<MyCustomExpandIcon />}
+  slots={{ expandIcon: MyCustomExpandIcon }}
 >
   {items}
 </SimpleTreeView>

Copy
Note that the slots prop expects a React component, not the JSX element returned when rendering this component.

If you were passing another icon to your <TreeItem /> component, you need to use the new expandIcon slot on this component:

  <SimpleTreeView>
    <TreeItem
      itemId="1"
      label="Item 1"
-     expandIcon={<MyCustomExpandIcon />}
+     slots={{ expandIcon: MyCustomExpandIcon }}
    />
  </SimpleTreeView>

Copy
Define
collapseIcon
The icon used to collapse the children of an item (rendered when this item is expanded) is now defined as a slot both on the <TreeView /> and <TreeItem /> components.

If you were using the ExpandMore icon from @mui/icons-material, you can stop passing it to your component because it is now the default value:

- import ExpandMoreIcon from '@mui/icons-material/ExpandMore';

  <SimpleTreeView
-   defaultCollapseIcon={<ExpandMoreIcon />}
  >
    {items}
  </SimpleTreeView>

Copy
If you were passing another icon to your Tree View component, you need to use the new collapseIcon slot on this component:

  <SimpleTreeView
-   defaultCollapseIcon={<MyCustomCollapseIcon />}
+   slots={{ collapseIcon: MyCustomCollapseIcon }}
  >
    {items}
  </SimpleTreeView>

Copy
Note that the slots prop expects a React component, not the JSX element returned when rendering this component.

If you were passing another icon to your <TreeItem /> component, you need to use the new collapseIcon slot on this component:

  <SimpleTreeView>
    <TreeItem
      itemId="1"
      label="Item 1"
-     collapseIcon={<MyCustomCollapseIcon />}
+     slots={{ collapseIcon: MyCustomCollapseIcon }}
    />
  </SimpleTreeView>

Copy
Replace
parentIcon
The parentIcon prop has been removed from the Tree View components.

If you were passing an icon to your Tree View component, you can achieve the same behavior by passing the same icon to both the collapseIcon and the expandIcon slots on this component:

  <SimpleTreeView
-   defaultParentIcon={<MyCustomParentIcon />}
+   slots={{ collapseIcon: MyCustomParentIcon, expandIcon: MyCustomParentIcon }}
  >
    {items}
  </SimpleTreeView>

Copy
Define
endIcon
The icon rendered next to an item without children is now defined as a slot both on the <TreeView /> and <TreeItem /> components.

If you were passing an icon to your Tree View component, you need to use the new endIcon slot on this component:

  <SimpleTreeView
-   defaultEndIcon={<MyCustomEndIcon />}
+   slots={{ endIcon: MyCustomEndIcon }}
  >
    {items}
  </SimpleTreeView>

Copy
Note that the slots prop expects a React component, not the JSX element returned when rendering this component.

If you were passing an icon to your <TreeItem /> component, you need to use the new endIcon slot on this component:

  <SimpleTreeView>
    <TreeItem
      itemId="1"
      label="Item 1"
-     endIcon={<MyCustomEndIcon />}
+     slots={{ endIcon: MyCustomEndIcon }}
    />
  </SimpleTreeView>

Copy
Define
icon
The icon rendered next to an item is now defined as a slot on the <TreeItem /> component.

If you were passing an icon to your <TreeItem /> component, you need to use the new icon slot on this component:

  <SimpleTreeView>
    <TreeItem
      itemId="1"
      label="Item 1"
-     icon={<MyCustomIcon />}
+     slots={{ icon: MyCustomIcon }}
    />
  </SimpleTreeView>

Copy
Note that the slots prop expects a React component, not the JSX element returned when rendering this component.

✅ Use slots to define the group transition

The component used to animate the item children is now defined as a slot on the <TreeItem /> component.

If you were passing a TransitionComponent or TransitionProps to your <TreeItem /> component, you need to use the new groupTransition slot on this component:

 <SimpleTreeView>
   <TreeItem
     itemId="1"
     label="Item 1"
-    TransitionComponent={Fade}
-    TransitionProps={{ timeout: 600 }}
+    slots={{ groupTransition: Fade }}
+    slotProps={{ groupTransition: { timeout: 600 } }}
   />
 </SimpleTreeView>

Copy
Rename the group class of the Tree Item component

The group class of the <TreeItem /> component has been renamed to groupTransition to match with its new slot name.

 const StyledTreeItem = styled(TreeItem)({
-  [`& .${treeItemClasses.group}`]: {
+  [`& .${treeItemClasses.groupTransition}`]: {
    marginLeft: 20,
  },
 });

Copy
✅ Rename onNodeToggle, expanded and defaultExpanded

The expansion props have been renamed to better describe their behaviors:

Old name	New name
onNodeToggle	onExpandedItemsChange
expanded	expandedItems
defaultExpanded	defaultExpandedItems
 <TreeView
-  onNodeToggle={handleExpansionChange}
+  onExpandedItemsChange={handleExpansionChange}

-  expanded={expandedItems}
+  expandedItems={expandedItems}

-  defaultExpanded={defaultExpandedItems}
+  defaultExpandedItems={defaultExpandedItems}
 />

Copy
If you were using the onNodeToggle prop to react to the expansion or collapse of a specific item, you can use the new onItemExpansionToggle prop which is called whenever an item is expanded or collapsed with its id and expansion status

// It is also available on the deprecated Tree View component
<SimpleTreeView
  onItemExpansionToggle={(event, itemId, isExpanded) =>
    console.log(itemId, isExpanded)
  }
/>

Copy
✅ Rename onNodeSelect, selected, and defaultSelected

The selection props have been renamed to better describe their behaviors:

Old name	New name
onNodeSelect	onSelectedItemsChange
selected	selectedItems
defaultSelected	defaultSelectedItems
 <TreeView
-  onNodeSelect={handleSelectionChange}
+  onSelectedItemsChange={handleSelectionChange}

-  selected={selectedItems}
+  selectedItems={selectedItems}

-  defaultSelected={defaultSelectedItems}
+  defaultSelectedItems={defaultSelectedItems}
 />

Copy
If you were using the onNodeSelect prop to react to the selection or deselection of a specific item, you can use the new onItemSelectionToggle prop which is called whenever an item is selected or deselected with its id and selection status.

// It is also available on the deprecated `<TreeView />` component
<SimpleTreeView
  onItemSelectionToggle={(event, itemId, isSelected) =>
    console.log(itemId, isSelected)
  }
/>

Copy
Focus the Tree Item instead of the Tree View

The focus is now applied to the Tree Item root element instead of the Tree View root element.

This change will allow new features that require the focus to be on the Tree Item, like the drag and drop reordering of items. It also solves several issues with focus management, like the inability to scroll to the focused item when a lot of items are rendered.

This will mostly impact how you write tests to interact with the Tree View:

For example, if you were writing a test with react-testing-library, here is what the changes could look like:

 it('test example on first item', () => {
   const { getByRole } = render(
     <SimpleTreeView>
       <TreeItem itemId="one" id="one">One</TreeItem>
       <TreeItem itemId="two" id="two">Two</TreeItem>
    </SimpleTreeView>
   );

   // Set the focus to the item "One"
-  const tree = getByRole('tree');
+  const treeItem = getByRole('treeitem', { name: 'One' });
   act(() => {
-    tree.focus();
+    treeItem.focus();
   });
-  fireEvent.keyDown(tree, { key: 'ArrowDown' });
+  fireEvent.keyDown(treeItem, { key: 'ArrowDown' });

  // Check if the new focused item is "Two"
- expect(tree)to.have.attribute('aria-activedescendant', 'two');
+ expect(document.activeElement).to.have.attribute('id', 'two');
 })

Copy
✅ Use useTreeItemState instead of useTreeItem

The useTreeItem hook has been renamed useTreeItemState. This will help create a new headless version of the Tree Item component based on a future useTreeItem hook.

-import { TreeItem, useTreeItem } from '@mui/x-tree-view/TreeItem';
+import { TreeItem, useTreeItemState } from '@mui/x-tree-view/TreeItem';

 const CustomContent = React.forwardRef((props, ref) => {
-  const { disabled } = useTreeItem(props.itemId);
+  const { disabled } = useTreeItemState(props.itemId);

   // Render some UI
 });

 function App() {
   return (
     <SimpleTreeView>
       <TreeItem ContentComponent={CustomContent} />
     </SimpleTreeView>
   )
 }

Copy
✅ Rename onNodeFocus

The onNodeFocus callback has been renamed to onItemFocus for consistency:

 <SimpleTreeView
-  onNodeFocus={onNodeFocus}
+  onItemFocus={onItemFocus}
 />
```

---

## File: package.json

```text
{
  "name": "ai-code-review",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://localhost:3001",
  "dependencies": {
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.15.3",
    "@mui/lab": "^6.0.0-beta.23",
    "@mui/material": "^5.15.3",
    "@mui/x-tree-view": "^7.24.0",
    "@octokit/rest": "^20.0.2",
    "@types/node": "^16.18.70",
    "@types/react": "^18.2.47",
    "@types/react-dom": "^18.2.18",
    "axios": "^1.6.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.21.1",
    "react-scripts": "5.0.1",
    "typescript": "^4.9.5"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

```

---

## File: tsconfig.json

```text
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"]
}

```

---

## File: nextSteps.md

```text
Next step changes to implement:

1. Jira Ticket Parsing – Only store key, summary, and description, omitting acceptanceCriteria and linkedEpics.

2. GitHub PR Fetch – Gather more fields from GitHub (e.g. author, created date, merges, etc.) to display a richer preview.

3. File Tree & Folder Expansion – Avoid errors when a folder is selected (i.e., “Error reading file …”), and allow folders to expand to show child files. This means adding a click-to-expand or arrow logic in FileTree.tsx that uses MUI’s TreeItem hierarchy.

4. Use systemPrompt.ts for a richer final prompt. Right now, your “Preview” step uses a minimal string. Incorporate your more robust generateSystemPrompt() from systemPrompt.ts so the user sees the same final system prompt that goes to the LLM.

Below is step-by-step guidance and example code snippets.

#1. Jira Ticket: Only Key, Summary, Description
In src/services/JiraService.ts, your getTicketDetails function transforms the Jira response into a JiraTicket. By default, it also tries to parse acceptance criteria and epics. You can simply omit them or parse them into description if that’s your preference. For example:


// src/services/JiraService.ts
import axios from 'axios';
import { JiraTicket, ApiResponse } from '../types';

export const getTicketDetails = async (ticketNumber: string): Promise<ApiResponse<JiraTicket>> => {
  try {
    const response = await axios.get(...);

    // Original code extracted acceptanceCriteria and linkedEpics
-   const ticket: JiraTicket = {
-     key: data.key,
-     summary: data.fields.summary,
-     description: data.fields.description,
-     acceptanceCriteria: data.fields.customfield_10000 || '',
-     linkedEpics: ...
-   };

+   // Only store what you actually need:
+   const ticket: JiraTicket = {
+     key: response.data.key,
+     summary: response.data.fields.summary,
+     // Combine acceptance criteria into the description if you'd like,
+     // or just store the raw description from Jira:
+     description: response.data.fields.description || ''
+   };

    return { success: true, data: ticket };

  } catch (error: any) {
    ...
  }
};
Adjust your JiraTicket type if needed:

typescript
Copy
export interface JiraTicket {
  key: string;
  summary: string;
  description: string;
  // Remove acceptanceCriteria, linkedEpics if not needed
}
Now your preview JSON for the Jira step will only have key, summary, and description.

#2. GitHub PR: More Data Fields
Octokit returns a rich PR object in prData. You can capture as many fields as you want in your getPullRequestDetails method. For instance:


// src/services/GitHubService.ts

export const getPullRequestDetails = async (
  prNumber: number,
  owner: string,
  repo: string
): Promise<ApiResponse<GitHubPR>> => {

  try {
    // Fetch PR details
    const { data: prData } = await octokit.pulls.get({
      owner,
      repo,
      pull_number: prNumber,
    });

    // Also fetch PR files
    const { data: files } = await octokit.pulls.listFiles({ ... });

+   // Additional fields from the PR
+   // e.g. user (the author), created date, state, labels, etc.
+   const author = prData.user?.login ?? '';
+   const createdAt = prData.created_at; 
+   const isMerged = !!prData.merged_at;
+   const mergeable = prData.mergeable;
+   const labels = prData.labels?.map(label => label.name);

    const pullRequest: GitHubPR = {
      number: prData.number,
      title: prData.title,
      description: prData.body || '',
      repo: { owner, name: repo },
      changedFiles: files.map(file => ({
        filename: file.filename,
        status: file.status as 'added' | 'modified' | 'removed',
        patch: file.patch,
      })),
+     author,
+     createdAt,
+     isMerged,
+     mergeable,
+     labels
    };

    return { success: true, data: pullRequest };

  } catch (error) {
    ...
  }
};
Then update your GitHubPR interface:

// src/types/index.ts
export interface GitHubPR {
  number: number;
  title: string;
  description: string;
  repo: { owner: string; name: string };
  changedFiles: GitHubFile[];
+ author?: string;       // the PR author’s login
+ createdAt?: string;    // date/time created
+ isMerged?: boolean;    // merged_at != null
+ mergeable?: boolean;   // can GitHub merge this PR?
+ labels?: string[];     // e.g. ['bug','enhancement']
}
Now your “Fetched PR” JSON will be more robust, giving you more context to display in the preview step.

#3. File Tree: Folder Expansion & Skipping Directory Concatenation

A. Expanding Folders

In your FileTree.tsx component (which uses MUI’s @mui/x-tree-view), you likely want to show an expand/collapse arrow. Right now you do display an arrow via slots={{ expandIcon, collapseIcon }} but you mention it’s not actually expanding. Ensure your TreeItems each have child TreeItems in their children prop, and that you’re using the correct SimpleTreeView expansions. For instance:

<TreeItem
  key={node.id}
  itemId={node.id}
  label={...}
>
  {node.children?.map((child) => renderTree(child))}
</TreeItem>
If you see “Error reading file” for a directory, that means your concatenate-files endpoint is trying to read a folder as a file. You should skip or handle directories differently:

// In /api/concatenate-files or your client code:
if (fsStat.isDirectory()) {
  // skip or recursively handle?
  // Usually skip, because you only want .txt, .ts, .js, etc. 
}
Key: The final fix is to ensure your selection logic never tries to read a directory. This can be done in FileTree by ignoring clicks on folder nodes or storing them but skipping them in the server. That’s up to your exact design.

B. Recursive Checking (if desired)
If you want to check a folder and automatically select everything inside it, you’ll need to implement a small helper function that does a DFS through the node’s children, collecting all file paths. We showed a snippet previously, but the main concept is:

// In handleCheck...
if (node.isDirectory) {
  const childPaths = getAllChildPaths(node);
  // add them to selected
} else {
  // toggle single file
}

#4. Use systemPrompt.ts for the ReviewSubmission Preview
Right now, your final preview is a small, ad-hoc template:

const promptString = `You are an expert-level code reviewer for TempStars... JIRA TICKET: ... PR: ... `;
But you already have a “systemPrompt.ts” that’s more detailed. To unify them, you can:

Import generateSystemPrompt from systemPrompt.ts.
Use that function in your ReviewSubmissionStep.tsx for the “Preview API Call” button as well as the final submission—so that what you see is exactly what goes to the LLM.
Example:

// src/components/Steps/ReviewSubmissionStep.tsx
+ import { generateSystemPrompt } from '../../prompts/systemPrompt';

const handlePreviewPrompt = () => {
  try {
    const jiraTicket = JSON.parse(localStorage.getItem('jiraTicket') || '{}');
    const githubPR = JSON.parse(localStorage.getItem('githubPRs') || '{}');
    const concatenatedFiles = localStorage.getItem('concatenatedFiles') || '';
    const referenceFiles = JSON.parse(localStorage.getItem('referenceFiles') || '[]');

    // Instead of ad-hoc:
-   const promptString = `You are an expert-level code reviewer...`;

+   const promptString = generateSystemPrompt({
+     jiraTicket,
+     githubPR,
+     concatenatedFiles,
+     additionalFiles: referenceFiles
+   });

    setPromptPreview(promptString);
  } catch (err) {
    ...
  }
};
This ensures your preview is the same rich prompt you’d expect in the final LLM call.

#5. Improving Formatting & Sections in the System Prompt
If you want your prompt’s sections to appear more clearly, you can do something like:

// In systemPrompt.ts
export const generateSystemPrompt = ({ 
  jiraTicket, 
  githubPR, 
  concatenatedFiles, 
  additionalFiles 
}) => {

  return `
You are an expert-level code reviewer for TempStars...

1) Jira Ticket:
Key: ${jiraTicket.key}
Summary: ${jiraTicket.summary}
Description:
${jiraTicket.description}

2) GitHub Pull Request:
Number: ${githubPR.number}
Title: ${githubPR.title}
Author: ${githubPR.author || ''}
Created: ${githubPR.createdAt || ''}
// etc.

3) Concatenated Code:
${concatenatedFiles}

4) Additional Reference Files:
${(additionalFiles || []).join('\n')}

// ...
Please provide your review with these guidelines:
1. SUMMARY
2. CRITICAL ISSUES
3. RECOMMENDATIONS
4. POSITIVE HIGHLIGHTS
5. DETAILED BREAKDOWN
`.trim();
};
Feel free to reorganize sections or add new bullet points for clarity.

#Putting It All Together
Jira: Strip out acceptance criteria and epics from the final JSON if unneeded.
PR: Capture more data from GitHub by expanding your pulls.get payload.
File Selection:
Expand/collapse folders in the UI by ensuring your TreeItem has children.
Skip or handle directories gracefully in /api/concatenate-files.
(Optional) Implement recursive check if you want “folder check = all subfiles.”
System Prompt: In ReviewSubmissionStep, replace the minimal preview with a direct call to generateSystemPrompt(), so the user sees the exact prompt that will be sent to the LLM.
By doing these, you’ll have:

A Jira step that shows only the relevant fields.
A more comprehensive GitHub PR preview (author, creation date, labels, etc.).
A file tree that truly expands subfolders and doesn’t fail if a directory is selected.
A robust final system prompt that matches .cursorrules and ensures your LLM gets the full context.
```

---

## File: public/index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="AI Code Review Tool"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>AI Code Review</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html> 
```

---

## File: public/manifest.json

```text
{
  "short_name": "AI Code Review",
  "name": "AI Code Review Tool",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
} 
```

---

## File: src/index.tsx

```text
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import { ThemeProvider, createTheme } from '@mui/material';

const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
    },
    secondary: {
      main: '#dc004e',
    },
  },
});

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <BrowserRouter>
      <ThemeProvider theme={theme}>
        <App />
      </ThemeProvider>
    </BrowserRouter>
  </React.StrictMode>
);

```

---

## File: src/App.tsx

```text
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';
import { Box, Container, CssBaseline } from '@mui/material';

// Import steps (we'll create these next)
import JiraTicketStep from './components/Steps/JiraTicketStep';
import GitHubPRStep from './components/Steps/GitHubPRStep';
import FileSelectionStep from './components/Steps/FileSelectionStep';
import AdditionalFilesStep from './components/Steps/AdditionalFilesStep';
import ReviewSubmissionStep from './components/Steps/ReviewSubmissionStep';
import Step6ReviewResults from './components/Steps/Step6ReviewResults';

const App: React.FC = () => {
  return (
    <Routes>
      <Route path="/" element={<Navigate to="/jira-ticket" />} />
      <Route path="/jira-ticket" element={<JiraTicketStep />} />
      <Route path="/github-pr" element={<GitHubPRStep />} />
      <Route path="/file-selection" element={<FileSelectionStep />} />
      <Route path="/additional-files" element={<AdditionalFilesStep />} />
      <Route path="/submit-review" element={<ReviewSubmissionStep />} />
      <Route path="/review-result" element={<Step6ReviewResults />} />
    </Routes>
  );
};

export default App;

```

---

## File: src/types/global.d.ts

```typescript

```

---

## File: src/types/index.ts

```typescript
// Jira related types
export interface JiraTicket {
  key: string;
  summary: string;
  description: string;
}

// GitHub related types
export interface GitHubFile {
  filename: string;
  status: 'added' | 'modified' | 'removed';
  patch: string | undefined;
}

export interface GitHubPR {
  title: string;
  description: string;
  number: number;
  repo: {
    owner: string;
    name: string;
  };
  changedFiles: GitHubFile[];
  author?: string;
  createdAt?: string;
  isMerged?: boolean;
  mergeable?: boolean;
  labels?: string[];
}

export interface PRDetails {
  frontend: GitHubPR | null;
  backend: GitHubPR | null;
}

// File selection types
export interface FileNode {
  path: string;
  type: 'file' | 'directory';
  children?: FileNode[];
  selected?: boolean;
}

// Review context types
export interface ReviewContext {
  jiraTicket: JiraTicket | null;
  githubPR: GitHubPR | null;
  selectedFiles: string[];
  additionalFiles: string[];
}

// API Response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
} 
```

---

## File: src/references/designCodingStandards.md

```text
# Design & Coding Standards

[Design and coding standards content will go here] 
```

---

## File: src/references/businessContext.md

```text
TempStars Business Context

1. Introduction
TempStars is a two-sided marketplace platform (web and mobile) that connects dental offices (“Demand”) with dental professionals (aka “Talent” or “Supply”) for both temping and hiring in North America. Often referred to as “Uber for Dental Temping and Hiring,” TempStars provides an efficient and transparent way for dental offices to find temporary or permanent staff, while giving dental professionals a flexible way to earn income and gain work experience.
Founder & CEO: Dr. James Younger, DDS — a practicing dentist who built TempStars out of a personal need to find reliable temp hygienists.
Founded: 2015, in Oakville, Ontario, Canada (prior to Uber’s expansion into Ontario).
Mission: Improve the work lives of dental professionals.
Regions: Canada (strongest penetration in Ontario) and the United States (expanding in markets like Chicago, Boston, Orlando, Phoenix, Vancouver).
Technology:
SQL Database hosted on AWS
Web App, iOS, and Android platforms

2. Key Value Propositions
Temping Services
Direct digital connections for Dental Hygienists and Dental Assistants looking for flexible shift work.
Allows Dental Offices to quickly find and book qualified professionals.
Job Board (Permanent & Contract Roles)
Dental offices can post long-term or permanent job openings for any dental role (Hygienists, Assistants, Admin, Office Managers, Associate Dentists).
Dental professionals can search and apply to these open positions.

3. Revenue Model
Temping Shift Fees
Canada: TempStars charges dental offices $57 (plus HST) for each completed temping shift.
United States: TempStars charges dental offices $38 for each completed temping shift.
Job Board Fees
Posting a job: Free for dental offices to post.
Viewing Applicant Details: $18 to unlock the full contact details and resume of each applicant using a resume viewing ‘token-based’ system.
Payment Processing Fee (Optional)
After a completed temping shift, a dental professional can use TempStars invoicing feature to create and send an invoice to the dental office.  When this is done, the dental office has the option to use “Pay Now” to pay the Talent.  
TempStars then charges the dental office’s credit card the amount of the Talent’s invoice and forwards payment to the Talent.
TempStars Fee (revenue): 4.75% added as a convenience and processing fee (covers credit card fees plus a small margin).

4. Organizational Structure
Below is a simplified snapshot of the TempStars org chart and key roles.
Executive Leadership
Founder & CEO: James Younger, DDS
VP Operations: Mallorie Hurst
VP Product: James Younger
VP Growth: Vacant
General & Administrative
Legal
Corporate Attorney (Rob Hyndman) – contracts, corporate structure
Employment Attorney (Stuart Rudner) – employment law & contracts
Finance
Finance Analyst (David Wright) – financial modeling, estimate-to-actuals
Controller (Erin Black) – analysis, forecasting, detailed reports
Bookkeeper (Erin Black) – AR/AP, monthly close
Human Resources
Hiring/HR: James Younger
Product & Engineering
Product Management: Holly Broderick + James Younger
Product QA: Holly Broderick
Lead Product Designer: James Younger
UX Designer: A.I. Assistant
DevOps & CTO: Yen Hsiao
Software Developers: Oleh Sak, Yusuf Abdulla
Admin Panel Developer / Data Visualization: Alex McAndrew
Growth & Operations
Marketing
Marketing Director (Danny Pham) – SEO, SEM, email, newsletters, paid ads, etc.
Social Media Manager (Vacant) – organic channels, content creation
Customer Service
Member Support Manager (Lucy Ferreira) – Tier II support, knowledge base, support systems
Member Success Agent (Andreal & Shelby & Chelsea) – ticket resolution, outbound shift fills
Membership Integrity Agent (Liza) – membership quality, payment follow-up
Business Development & Partnerships: Malloy Hurst 
Onboarding
Onboarding & Relationship Manager (Shelby) – helps dental offices get started

5. Temping Process Overview
When a dental office needs a temporary professional, they post a shift. A “shift” and a “job” can be used interchangeably, but in practice, “job” often refers to a permanent opening in the job board, while “shift” is for temp work for the temping service.
Shift Posting
Dental office posts shift details: date, time, role, preferred hourly rate, any special requests.
(Optional) “Auto-Book” or “Instabook” features for quick booking of top-rated professionals.
Shift Browsing
Dental professionals (hygienists/assistants) browse available shifts through the app or web platform, using filters and the system ensures only qualified Talent view shifts that are a match for them.
Offer Submission
Professionals submit an offer to work, possibly customizing their hourly rate (via a rate selector).
Offer Review & Booking
Dental offices see offers (including professional’s resume, graduation year, rating score, offered rate) and either accept or decline.
Upon acceptance, both parties receive confirmation emails/notifications.
Shift Execution
Professional arrives on the scheduled day, performs the shift, and upholds professional standards.
Invoicing & Payment
Professional generates an invoice through TempStars or via personal means.
Office pays through TempStars’ payment platform (optional) or through another method (e.g., the office can pay talent themselves directly via  e-transfer, check).
Reviews
After each shift, both parties leave a rating/review “How happy were you with this connection?”.
Ratings are simplified into three categories: “Favourite” (5-star), “Happy” (~4.2-star), or “Unhappy” (2-star).
“Gardener” Algorithm
Manages professional statuses (e.g., Pro, Elite, Probation, Revoked) based on reliability, feedback, and overall performance.
May require remedial courses for those falling below reliability standards.

6. Hiring Process via Job Board
Job Posting
Dental office logs in and posts a permanent or contract position (role, contract length, salary, benefits).  This job board service works similar to online classified ads, customized for dentistry.
Candidate Applications
Dental professionals see listings and apply, providing resume/qualifications.
Contact Info Unlock
The dental office pays $18 to purchase a token that allows access the applicant’s full information (contact details, resume).
Interview & Hiring
TempStars does not manage the full funnel of interview scheduling, but offices and candidates communicate directly once contact info is unlocked.

7. User Journeys
Demand Side (Dental Offices)
Awareness & Sign-up
Offices discover TempStars via word-of-mouth, digital marketing, trade shows, email campaigns, channel partners.
Create account with office details, location, payment method (credit card), compliance steps, etc.
Posting a Shift
Enter shift details: date, time, hourly rate, type of role needed. Optionally enable Instabook or Auto-Book.
Receiving Offers & Booking
Review the offers, possibly negotiate or decline with a reason.
Shift Day & Payment
Expect the professional to arrive on time; handle any disputes through TempStars support.
Pay by “Pay Now” or an alternative method.
Review & Retention
Rate the professional after the shift.
No formal loyalty or retention program is currently in place.
Supply Side (Dental Professionals)
Discovery & Sign-up
Register through TempStars website or app; provide email, role, location, qualifications.
Shift Browsing & Offers
Browse shifts that match location, date, pay range.
Submit an offer with a desired rate (or accept the listed rate).
Await Response
Dental office can accept or decline. Some offices may make a counter-offer.
Executing the Shift
Arrive on time, maintain professional standards, be ready for potential staff meetings or safety protocols.
Invoicing & Payment
Generate invoice in-app or externally.
If using TempStars’ “Pay Now,” the platform processes payment and deposits funds, minus any relevant fees.
Review & Continuous Engagement
Rate the dental office; keep looking for additional shifts or permanent roles.

8. Community & Reliability Management
Bilateral Review System: Both parties can leave feedback.
Status Levels: Pro, Elite, Probation, Revoked.
The “Gardener” Algorithm: Tracks reliability (no-shows, cancellations, user ratings). Good performers achieve higher status levels, while unreliability can lead to probation or revocation.
Remediation: Professionals with negative patterns may be assigned remedial training.

9. Strategic Goals (as of 2025)
Defend and grow market leadership in Ontario (Canada).
Gain traction in Orlando, Phoenix, Boston, and Vancouver.
Build a stronger community with mentorship, discussion forums, and lifestyle elements.
Prepare for scale: Strengthen processes, systems, team structure, and infrastructure for expansion.

10. Important Metrics & Success Indicators
Time to First Completed Shift: How quickly new professionals or offices complete their initial temping engagement.
Number of Shifts per Month: A measure of both supply and demand activity.
Retention Rate: Whether offices and professionals return to TempStars for additional shifts/hiring.
Feedback Ratings: Overall satisfaction, reliability, performance.
Cancellation Rates: Monitors how often shifts are canceled (and by whom).
Revenue Growth: Tied to completed shifts, job board unlock fees, and payment processing fees.

11. Common Pain Points & Challenges
For Dental Offices
Last-minute cancellations or no-shows by professionals.
No “bulk payment” option (have to pay each professional individually).
No robust loyalty or incentive program to encourage repeated usage.
For Dental Professionals
Anxiety about whether offers will be accepted or not.
Potential workplace safety or office environment concerns.
Handling negative feedback—lack of a robust mechanism for dispute resolution besides direct support.

12. Support & Customer Service
Customer Support: Inbounce Email, outbound phone as needed and requested, and in-app messaging with a typical response within an hour. Urgent matters prioritized.
Knowledge Base: Articles, FAQs, and a “Handbook for Success.”
Remedial Courses: For members on probation or who fall below reliability thresholds.
No Official Community Forum: Currently, there is no integrated forum, though the company’s strategic roadmap includes possible community-building features.

13. Legal & Employment Considerations
Canada vs. US: Different approaches (1099 vs. W2, or contractor vs. employee classification). TempStars provides some transparency but leaves final classification to the parties.
TempStars is not the employer: TempStars allows the dental offices to connect with the talent, but the definition of the working relationship is determined by the dental office and talent.  TempStars does not dictate that relationship, and Talent are not employees of TempStars.
Confidentiality & Compliance: Offices must confirm infection control and workplace safety compliance.
Disintermediation Risk: Because shift and office details are transparent, parties could theoretically engage outside the platform. TempStars combats this by building trust, convenience, and features that incentivize ongoing usage, such as Payment Guarantee, Safety Guarantee and other value benefits for talent to log any shifts booked through direct connection.

14. Additional Notes & Terminology
“Job” vs. “Shift”:
“Shift” typically refers to temp or one-time assignments.
“Job” often refers to permanent/long-term positions posted on the job board.
Instabook: A feature allowing Pro or Elite professionals to instantly book shifts without the dental office manually approving each offer, the hourly rate in Instabook is the “Proposed Rate” indicated by the office at the time of posting.
Auto-Book: Automates matching if a professional’s availability and desired rate align with an office’s shift details.
“Pay Now”: TempStars’ optional in-platform payment processing function.
Ratings:
Favourite (5-star): Equivalent of a perfect rating.
Happy (4.2-star): Positive overall rating.
Unhappy (2-star): Indicates significant dissatisfaction.

15. Summary
TempStars is a leading dental temping and hiring marketplace. By focusing on ease of use, transparency, and a bilateral review system, it streamlines how dental offices fill last-minute or permanent roles while enabling professionals to maintain flexible, rewarding careers. The company’s unique “Gardener” algorithm fosters reliable and high-quality community standards, and the strategic roadmap emphasizes ongoing expansion, community-building, and improved user experiences.
Use this context to answer questions or provide insights regarding:
TempStars’ core operations, platform features, and user journeys.
Revenue model and fees.
Organizational structure and team responsibilities.
Strategic growth plans, user experience, and product roadmap.
Common challenges and how they’re addressed.

Addendum: Additional Key Context
A. Revenue Model Details (Expanded)
Shift Fees & HST
In Canada, TempStars charges $57 plus HST (Harmonized Sales Tax) for each completed temping shift. The HST rate depends on the province in which the shift occurs.
In the United States, TempStars charges $38 per completed temping shift.
Job Board Tokens
Dental offices purchase tokens in advance to view candidates’ full contact details and resumes for permanent or contract positions.
Each candidate “unlock” costs $18 worth of tokens. Once the tokens are purchased, they are stored in the dental office’s TempStars account until used.
Payment Processing Fees
“Pay Now” is an optional service allowing TempStars to process payment on behalf of the dental office once a professional invoices them in the platform.
TempStars charges a 4.75% fee on the invoice amount, covering credit card charges and providing a small profit margin.
If dental offices or professionals choose not to use “Pay Now,” no processing fees are charged.

B. Mission, Vision & Values (Expanded)
1. Mission
TempStars’ overarching mission is to improve the work lives of dental professionals. This mission transcends simple job-matching by also fostering career growth, flexible opportunities, and positive workplace experiences.
2. Vision
To be the first, best, and top-of-mind service for:
Dental offices seeking reliable professionals for temping and hiring.
Dental professionals striving to find the ideal balance, environment, and professional growth opportunities.
This vision aims to enhance not only the quality of the dental profession but also patient experiences, access to care, and oral health in society as a whole.
3. Core Values
Community Stewardship & Service to the Dental Profession
Recognizes the responsibility to nurture a unified dental community built on mutual respect and collaboration.
Trustworthiness
Emphasizes honesty, transparency, and accountability in all interactions. Data, feedback, and open dialogue guide improvement.
Strength Through Constraints
Belief that working within constraints (like budgets, timelines, or regulations) fosters creativity, resiliency, and innovation.
Data-Informed Decisions
Uses empirical evidence for decision-making while avoiding “analysis paralysis.”
Considerate & Diligent Management
Ensures thorough oversight of platform operations, user satisfaction, and overall community well-being.
Delight
Strives to create positive, surprise-and-delight experiences for both dental offices and professionals.
Inspirational Teamwork
Cultivates an internal culture where collaboration, mutual support, and personal growth thrive.
Growth, Learning & Adaptation
Values ongoing skill development, professional growth, and the flexibility to adapt to shifting market or user needs.

C. Business Opportunities (Future Growth)
Premium Subscription Models
Offer offices an option subscription based on their trailing 90 day usage - so instead of transactional per shift, offer more shifts for less per month - so there is a recurring revenue and stickiness benefit to be gained there.
“Boosted Posts”
Dental offices can pay to highlight or boost postings for temping or hiring
Shift Protection Insurance
Offices can check a box to purchase “Shift Protection” insurance where the office gets compensate for lost revenue if a Talent cancels a shift and a replacement is not found.  Actuarial analysis needed.
Enhanced Recruitment Services
Going beyond simple job postings to offer end-to-end candidate tracking resources and features optimized for screening, candidate matching, interview scheduling, and onboarding.
White Glove Concierge Service
Dedicated “high-touch” services for larger offices or professionals who want personalized help with scheduling, recruiting, and shift management.
DSO (Dental Service Organization) Enterprise Solutions
Custom dashboards and volume-based pricing for DSOs managing multiple locations, along with API integrations into existing HR and scheduling systems.

D. Technical Infrastructure (Expanded)
SQL Engine Version
TempStars runs on SQL Engine 5.7.38 hosted on AWS, which introduces certain constraints (e.g., no native window functions as in later SQL releases, index limitations, etc.).
Database Schema Specifics
A relational database structure forms the backbone, with separate tables for Users (dental offices, professionals), Shifts, Ratings, Payment Transactions, etc.
Foreign key relationships and indexing are used to optimize performance across typical usage spikes (e.g., morning shift searches).
API Integrations
Plans to develop or extend APIs for enterprise-level integrations with DSOs, large dental networks, or third-party HR systems.
Potential for webhooks that notify offices when new professionals match their search criteria or vice versa.

E. Definitions & User Classification
Active vs. Non-Activated Users
Active (Offices): Posted at least one temp shift or job board listing within the past 45 days.
Active (Professionals): Submitted an offer for a temp shift or applied to a permanent position within the past 45 days.
Non-Activated: Users who created an account but never performed any activity (no postings or offers).
Churned Users
Users (office or professional) who have not performed any activity for more than 45 days.
ReActivated Users
Previously churned users who resumed activity (posted a new shift, applied for a job, or submitted an offer) after 45+ days of inactivity.
Activity Metrics
Dental Offices: Number of posted shifts/jobs, acceptance rates, payment completions.
Professionals: Number of offers submitted, shifts completed, acceptance rates, feedback scores.

F. Market Analysis
Competitive Landscape
Platforms like direct hiring sites, local staffing agencies, or other specialized healthcare temping websites.
TempStars differentiates itself through ease-of-use, transparent shift details, and a robust reliability and review system.
Market Size & Potential
The broader North American dental market includes tens of thousands of offices, with many lacking a streamlined way to fill last-minute or permanent staffing needs.
Huge potential for capturing expanded geographies and specialized roles (office managers, front desk, associate dentists).
Regional Growth Strategies
Ontario: Continue defending market leadership through brand loyalty, local partnerships, and premium services.
Chicago & Boston: Focus on early adopter offices and strong word-of-mouth referrals, building a beachhead of reliable, top-rated professionals.
Expansion Markets: Orlando, Phoenix, Vancouver, etc.—leverage localized marketing, trade shows, and strategic partnerships with professional associations.

G. TempStars’ Foundation & Core Philosophy
Deeper Purpose
Beyond facilitating transactions, TempStars aims to be a force for positivity in the dental community, improving patient outcomes and helping professionals discover more fulfilling careers.
Community Stewardship
Because they hold a central role in connecting offices and professionals, TempStars champions a cooperative ethic. They navigate potential conflicts (e.g., offices vs. professionals) with fairness and open communication.
Trust and Transparency
Clear shift details, office environment notes, and open ratings foster an environment of honesty and accountability.
Emphasis on open dialogue: both with the user community (for feedback) and internally (for continuous improvement).
Data-Informed, Human-Centric
While data helps guide decisions, TempStars also weighs the human experience to avoid simply maximizing numbers at the expense of community trust or individual user needs.
Flexible, Empowering Work Arrangements
Encouraging professionals to choose their hours, roles, and pay rates fosters empowerment. Dental offices likewise gain confidence from a pool of high-quality professionals to keep their practice running smoothly.
Balancing Disintermediation Risks
Full transparency about offices and shift details can lead to “going direct” outside the platform. TempStars balances this risk by adding enough value (convenience, reliability, quality control, support, community features) that both parties prefer staying within the platform.

H. Metrics, KPIs, and Performance Benchmarks
TempStars uses a multifaceted measurement system to evaluate success across different user segments and market phases.
Dental Office Onboarding & Activation
Activation Period: Measures the time from when a dental office creates an account to when it posts its first shift.
14-Day Benchmark: Offices that post their first shift within 14 days of sign-up show significantly higher long-term retention and ongoing engagement.
Retention Link: Shorter activation periods correlate with increased likelihood of recurring shift postings and job board usage.
Office Engagement & Fill Rate
Primary KPI: “Fill Rate” — the percentage of posted temp shifts that successfully match with talent.
Market Maturity Targets:
Established Markets (e.g., Ontario) commonly achieve 85%+ fill rates.
Newer Markets often begin at 60–70% as talent pools are being formed.
Healthy Market Threshold: Markets are deemed stable and “healthy” when consistently maintaining a 75% or higher fill rate.
Talent Metrics
Offer Acceptance Rate: Tracks how often a professional’s shift offers are accepted by dental offices.
Top Performers (Pro or Elite) often exceed 80% acceptance rates.
Reliability Score: Aggregates punctuality, cancellation rates, and office feedback into a score out of 5.0.
Minimum Good Standing: 4.0+
Pro Status: 4.5+
Elite Status: 4.8+
Revenue Growth by Market Phase
Launch Phase: Key objective is user acquisition; focus on building a robust office and talent base.
Growth Phase: Target 20% month-over-month increase in completed shifts.
Mature Phase: Sustain 5% monthly growth while keeping satisfaction and fill rates high.

I. Regulatory Compliance Framework
TempStars operates under a complex network of healthcare and employment regulations across Canada and the United States. The platform’s approach involves continuous monitoring, documentation, and auditing to ensure compliance with each jurisdiction’s unique requirements.
Canadian Regulations
Provincial Healthcare Standards: Offices must confirm adherence to their province’s infection control and professional practice guidelines.
Ontario: Must meet Royal College of Dental Surgeons of Ontario (RCDSO) standards.
British Columbia: Follows College of Dental Surgeons of BC guidelines.
Professional Licensing: TempStars verifies that all hygienists and assistants hold valid provincial registrations or certificates.
Employment Classification: Since TempStars is not the direct employer, it must ensure its platform structure aligns with independent contractor regulations and provincial labor standards.
U.S. Regulations
State Dental Boards: Each state enforces different rules for temporary staffing (e.g., license requirements, infection control).
Compliance Matrix: TempStars maintains a state-by-state matrix detailing these requirements, including liability insurance, worker classification (1099 vs. W2), and labor laws.
Worker Classification: TempStars avoids misclassification by clearly documenting the independent nature of the professional-office relationship, referencing relevant state and federal guidelines.
Safeguards & Verification Processes
Automated License Verification: Professionals must upload valid credentials; the system checks for expiration or invalid status.
Compliance Attestations: Dental offices confirm adherence to provincial/state infection control standards before posting shifts.
Audits & Reviews: Regular checks of user documentation, including license renewal reminders and required continuing education.
Transparent Communication: Both professionals and offices receive clear documentation about their relationship and classification options.
Data Privacy & Security
PIPEDA (Canada) & State Privacy Laws (U.S.): TempStars follows these regulations to securely handle user data, including payment details and personal identifiers.
Policy Updates: TempStars periodically revises its privacy policies to remain compliant with evolving privacy legislation.
Security Measures: Uses AWS best practices for data encryption, access control, and routine penetration testing to safeguard sensitive information.
Through these targeted metrics, structured KPIs, and a robust regulatory framework, TempStars ensures both operational excellence and trustworthiness in an industry that demands high standards of professionalism, safety, and compliance.

End of Business Context

```

---

## File: src/references/databaseSchema.md

```text
# Database Schema Reference

> This document provides database schema context for AI-powered code reviews.

**##TempStars SQL Database and Schema**

TempStars is web and mobile based two-sided marketplace platform that connects dental offices (“Demand”) with dental professionals (“Supply” aka “Talent”) for temping and hiring.   \
 \
Definition of Terms:

“Job Board” is TempStars service for hiring connections, either for contract or permanent positions.  For the Job Board, dental offices post a “Job” and Talent apply to the Job posting as candidates or applicants.  The Job Board is similar to “Indeed” but for dentistry.  The Talent for the Job Board are dental hygienists, dental assistants, dental office managers, dental admin and associate dentists.

“Temping” is TempStars service for fast and easy temping connections.  These are one-day “Shifts” where the dental office needs a temporary dental hygienist or dental assistant to fill in temporarily for a day.  For “Temping”, dental offices post a “Shift” and Talent send in “Offers”.  Talent for Temping is restricted to dental hygienists and dental assistants.

The following headings, description and columns are a description of TempStars database schema.

TempStars uses an AWS instance of RDS SQL database running SQL Engine version 5.7.38, and does not support ‘with’ statements, so write all queries to be compatible with SQL Engine version 5.7.38

**<span style="text-decoration:underline;">“Hygienist” Table</span>**

**Description**: Stores information about Talent records (ie. dental hygienists, dental assistants, dental office managers, dental admin and associate dentists).   \
 \
Note:  There is no email column in this table.  Talent emails are stored in the User table.  To retrieve Talent email addresses, you need JOIN User ON User.hygienistId = Hygienist.id) \


**Columns**:

	•	id (int): The ID of the Talent.

	•	firstName (varchar): The first name of the Talent.

	•	lastName (varchar): The last name of the Talent.

	•	type (int): Differentiates between dental hygienists (0) and dental assistants (1) and dental admin (2) and associate dentists (3).

	•	createdOn (datetime): Registration timestamp for the Talent. “NULL” if the registration process was not completed.

	•	city (varchar): The city where the Talent lives.

	•	province (varchar): The province or state where the Talent lives.

	•	postalCode (varchar): Indicates the Postal Code (in Canada) or Zip Code (in United States) where theTalent lives.

	•	country (int): Indicates the country in which the Talent lives (0 = Canada, 1 = United States)

	•	graduationYear (int): The year when theTalent graduated from their professional school.

	•	status (int): Differentiates between membership status for Talent. (-3: “Blacklisted” means no access to Job Board or temping, -2: “Blocked” means access to Job Board but no access to temping, -1: “Probation” means Talent can only book one shift at a time, 0: “Active” means Talent has full access to temping and Job Board, 1: “Pro” means tTalent has attained a level of great reliability and professionalism and positive feedback with between 5 and 10 temping shifts completed, 2: “Elite” means Talent has attained an exceptional level of professionalism, reliability and positive feedback with more than 10 shifts completed.

	•	lat(varchar) and lon(varchar): Indicates the latitude and longitude of where the Talent lives

•	stripeAccountId: NOT NULL when Talent has registered for Stripe Express Payouts, and the value in this field represents the unique ID for the Stripe Express account set up by the Talent.

•	isOrtho: Indicates the Talent is qualified to provide orthodontic treatment (1: is qualified, 2: is not qualified)

•	isRestorative: Indicates the Talent is qualified to provide restorative dental treatment (1: is qualified, 2: is not qualified)

•	isComplete: Indicates the Talent has completed signup registration (1: has completed sign-up)

**<span style="text-decoration:underline;">“Location” Table</span>**

**Description:** Stores details of dental office Locations.  Remember that “Location” refers to a dental office location of business, and is not the geographic location.  So in this context, “dental office” and “location” are used interchangeably.

**Columns**:

	•	id (int): The ID of the dental office location.

	•	practiceName (varchar): The name of the dental office location.

	•	city (varchar): The city where the dental office is located.

•	createdOn (datetime):  The date the Location signed up with TempStars \
	•	email (varchar):  The email of the Location

	•	phone (varchar):  The phone number of the Location

	•	province (varchar): The province or state where the dental office is located, using standard 2-letter abbreviations for states and provinces.

	•	postalCode (varchar): The postal code or zip code of the dental office.

	•	country (int): Indicates the country where the dental office is located (0 = Canada, 1 = United States)

	•	isCentralBooked (int): Indicates if the Location is part of a large dental corporation (aka a ‘DSO’) (0: Not corporate, 1: ‘Dentalcorp’ DSO Corporate location, 2: ‘123Dentist’ Corporate location).

	•	lat(varchar) and lon(varchar): Indicates the latitude and longitude of where the dental office is located.

	•	stripeCustomerId (varchar): If the dental office has entered payment information into their account the stripeCustomerId  the Stripe Account ID.  This value is NULL if the dental office has not entered payment information.

	•	defaultProposedRateHygienist (int): Indicates the default proposed hourly rate that the dental office pays Hygienists

	•	defaultProposedRateAssistant (int): Indicates the default proposed hourly rate that the dental office pays dental assistants.

	•	ppeEndorsed (int): Indicates the number of times that Talent have indicated the office has PPE and Infection control standards that meet or exceed requirements.

	•	friendlyEndorsed (int): Indicates the number of times that Talent have indicated that the office is a friendly place to work.

•	equipEndorsed (int): Indicates the number of times that Talent have indicated the office has good tools and equipment.

•	vaxRequired (int): Indicates if the dental office has a policy in place that requires employees to be vaccinated against COVID. 

**<span style="text-decoration:underline;">“Job” Table</span>**

**Description**: Stores information related to TempStars “Temping” service.  Stores information about  shifts that are posted by dental offices, and the details of the working connection if the shift is booked and/or completed by Talent.  Temping is only for dental hygienists and dental assistants.

**Columns:**

	•	status (int): The status of the shift (1: Posted, 2: Has at least one offer from Talent 3: Booked, 4:Completed, 5: Had received offers but all offers expired, 6: The shift posting was active but went unfilled and was not completed by the startDate, 7: canceled or removed by the dental office).

	•	startDate (YYYY-MM-DD): The actual date the shift is to be worked by Talent.  **Important note: ** Because Job.startDate is in the “YYYY-MM-DD” format, you often need to convert it to a different format (“YYYY-MM-DD hh:mm:ss”) for data analysis.

	•	locationId (int): The ID of the dental office Location that posting the temping shift.

	•	hygienistId (int): Indicates the ID of the Talent who is booked for the shift.  Has a value of ‘0’ of the shift is not booked, and the ID of the Talent booked for the shift if the value is greater than 0. (0: not booked, >0: Talent is booked). 

	•	dentistRating (int): Review score given by the Talent to the dental office (Note: a value “0” value means the dental office was unrated)

	•	hygienistRating (int): Review score given by the dental office to the Talent  (Note: “0” value means the Talent was unrated).

	•	dentistBilled (int): Indicates whether TempStars placement fee was collected (0: not collected, 1: collected) for a completed shift.

	•	hourlyRate (decimal): Indicates the hourly rate earned by the Talent working the shift (the value indicates dollars per hour).

	•	postedOn (date): Indicates when a temping shift was posted on TempStars service by the dental office.

	•	type (int): Indicates if the shift requires a Hygienist (0) or Dental Assistant (1).

	•	bookedOn (datetime): Indicates the timestamp of when the shift booking was confirmed between the dental office and the Talent.

	•	dentistPrivateNotes (varchar): Indicates any private feedback notes the dental office made about the Talent who worked the shift

	•	hygienistPrivateNotes (varchar): Indicates any private feedback notes the Talent made about the dental office where the shift was completed.

**<span style="text-decoration:underline;">“User” Table</span>**

**Description**: Stores user information, including email addresses.

**Columns:**

	•	email (varchar): The email of the user.  NOTE:  Do not use this field for dental office location emails.  When referencing dental office location emails, only use Location.email fields.  Do use  this column for Talent emails by JOIN User.hygienistId = Hygienist.id.

	•	hygienistId (int): The ID of the Talent associated with the User record.

	•	dentistId (int): This is NOT NULL if the User record is related to a dental office location.

	•	platform: Indicates the platform used for signing up (NULL means web, “Android” means Android, iOS means iPhone).

	•	referredBy (int): This column identifies the User.id of the user that referred the current user record to the platform.  For example:  If User.id ‘5678’ has a User.referredBy value of ‘1234’, then this means that User ‘5678’ was referred by User ‘1234’.

**<span style="text-decoration:underline;">“PartialOffer” Table</span>**

**Description:** Talent submit offers to work temping shifts posted by Dental Offices.  The “PartialOffer” table table stores details of offers made by Talent for those temping shifts.

**Columns:**

	•	jobId (int): The ID of the temping shift associated with the offer (ie. JOIN Job ON Job.id = PartialOffer.jobId)

	•	hygienistId (int): The ID of the Talent who sent the offer (ie. JOIN Hygienist ON Hygienist.id = PartialOffer.hygienistId)

	•	createdOn (datetime): The timestamp of when the offer was sent.

	•	hourlyRate (decimal): The hourly rate offered by the Talent for the shift.

	•	numViews (int): The number of times the offer was viewed by the dental office.

	•	firstViewed (datetime): The timestamp of when the offer was first viewed by the dental office.

	•	lastViewed (datetime): The timestamp of the most recent viewing of the offer by the dental office

	•	status (int): Differentiates the role of user  (0: Sent, 1: Rejected, 2: Accepted/Booked, 3: Expired, 4: Removed by Talent)

**<span style="text-decoration:underline;">“DentistCancelled” Table</span>**

**Description**: Sometimes dental offices cancel a shift that is booked.  The DentistCancelled table tracks the details when dental offices cancel a shift.

**Columns**:

	•	jobId (int): The ID of the canceled shift (ie. JOIN Job ON Job.id = DentistCancelled.jobId)

	•	locationId (int): The ID of the location that canceled the shift (ie. JOIN Location ON Location.id = DentistCancelled.locationId)

	•	cancelTimeStamp (datetime): The timestamp of when the shift was canceled by the dental office.

	•	shortNotice (int): Indicates whether the cancellation was short notice, less than 24hrs before the shift was scheduled to start (0: not short notice, 1: was short notice).

===
**<span style="text-decoration:underline;">“HygienistReliabilityScore” Table</span>**

**Description**: This table contains columns that indicate the objective score related to a hygienist’s reliability in booking and completing temping shifts.  A high reliability score indicates good performance, a low score indicates poor performance.  These values change as Talent completes shifts and cancels shifts.

**Columns**:

	•	HygienistId (int): The ID of the Talent in question who has a track record for reliability.

	•	cancellationScore (float): This represents a score related to the number and timing of Talent cancellations as they relate to the start of the shift.  Short-notice cancellations are worth more cancellation points, likewise cancelling a shift further ahead is lower points. But overall, lower points are better and mean a more reliable Talent.  

	•	overallReliability (float): This is a calculation based on a formula that takes into account the ‘cancellationScore’ and the number of  complete shifts by the Talent in their history of working with TempStars.

	•	recentReliability (float): This is a calculation based on a formula that takes into account the ‘cancellationScore’ and the number of  complete shifts by the Talent in the past 90 days.

	•	weightedReliability (float): This is a calculator that takes [(0.3 * overallReliability) + (0.7 * recentReliability0] to give an overall weighted score to indicate the Talents reliability, giving favour to their most recent shift reliability.

**<span style="text-decoration:underline;">“HygienistCancelled” Table</span>**

**Description**: Sometimes Talent cancels a shift that is booked.  The HygienistCancelled table tracks the details when Talent cancels a shift.

**Columns:**

	•	jobId (int): The ID of the canceled shift (ie. JOIN Job ON Job.id = HygienistCancelled.jobId)

	•	cancelTimestamp (datetime): Indicates when the shift was canceled by the Talent.

	•	rebookedBy (int): Indicates whether the shift was rebooked by another Talent.  The value is ‘0’ if the shift was not rebooked, and if the value is >0, that value is the HygienistID of the talent that rebooked the shift.

	•	hygienistId (int): Indicates the ID of the Talent who canceled the shift (ie. JOIN Hygienist ON Hygienist.id = HygienistCancelled.hygienistId)

**<span style="text-decoration:underline;">“BlockedDentist” Table</span>**

**Description:** Sometimes a Talent has such a bad experience working at a shift that they don’t want to see the dental office’s future shift postings.  This table tracks the details of that ‘blocking’.

**Columns:**

	•	locationId (int): The ID of the dental office that the Talent was unhappy with (ie. JOIN Location ON Location.id = BlockedDentist.locationId)

	•	hygienistId (int): The ID of the Talent who was unhappy with the dental office (ie. JOIN Hygienist ON Hygienist.id = BlockedDentist.hygienistID).

**<span style="text-decoration:underline;">RoleMapping” Table</span>**

**Description:** This table tracks the roles of all users based on role codes, and joins to the User table.

**Columns:**

	•	principalId (int): This is the User ID of the user.

	•	roleId (int): Differentiates between the role of the User (4: Dental Office, 6: Hygienist, 7: Dental Assistant, 8: Admin front desk, 9: Associate Dentist).

**<span style="text-decoration:underline;">“BlockedHygienist” Table</span>**

**Description:** Sometimes a dental office is so unhappy with a Talent that the office doesn’t want the Talent working at their office again.  This table tracks the details of that ‘blocking’, and indicates which Talent are unable to view temping shift postings from which locations.

**Columns:**

	•	hygienistId (int): The ID of the Talent that the dental office was unhappy with.

	•	locationId (int): The ID of the dental office that is blocking the specific Talent.

**<span style="text-decoration:underline;">“hireJob” Table</span>**

**Description:** TempStars has a Job Board for permanent and contract hiring which operates similar to classified ads or “Indeed” service.  Dental offices post a Job for a permanent or contract position.  Candidates submit their application to the Job Board posting, then it is up to the dental office to contact the candidate, arrange interviews and hire them to the team.  The “hireJob” table tracks the records relating to the Job Board posting done by the dental office. Note: While most tables in the database have a capitalized first letter, the “hireJob” table name begins with a lowercase ‘h’.

**Columns:**

	•	locationId (int): The ID of the dental office that is posting the Job.

	•	jobType (int): Indicates the type of Talent position required by the office in the Job Board posting (0: Dental Hygienist, 1: Dental Assistant, 2: Administrator/Manager, 3: Associate Dentist).

•	status (int): Indicates the status of the Job Board posting (0: Pending review, 1: Approved and active, 2: Removed by dental office 3: Expired listing).

	•	resumesViewed (int): A count of how many unique candidate resumes were viewed by the dental office for that Job Board posting.

	•	createdOn (timestamp): Indicates the date when the dental office posted the job to the Job Board.

**<span style="text-decoration:underline;">“JobApplications” Table</span>**

**Description:** TempStars has a Job Board for permanent and contract hiring, which operates similar to classified ads or “Indeed”.  Dental offices post a Job for a permanent or contract position.  The “JobApplications” table tracks the status of applications that candidates submit in the Job Board for a Job Posting.

**Columns:**

	•	hireJobId (int): The ID of the hireJob record that the JobApplication relates to (JOIN hireJob ON JobApplications.hireJobId = hireJob.id

	•	hygienistId (int): Indicates the Talent ID that submitted the application  for the Job Board posting.

•	createdOn (timestamp): Indicates when the Talent candidate submitted the application for the Job Board posting.

	•	resumeViewed (int): Indicates if the candidate application was viewed by the dental office (0: not viewed, 1: yes viewed).

•	status (int): Indicates the status of the candidate application. (0: submitted, 1: application viewed, 2: resume was opened 3: office contact details revealed, 4: application removed by candidate).

	•	interviewStatus (int): Indicates if the candidate’s application is designated for an interview. (0: not viewed, 1: viewed, 2: interview scheduled).

	•	resumeViewedOn (timestamp): Indicates the datetime when the dental office first viewed the candidate application.

**<span style="text-decoration:underline;">“Invoice” Table</span>**

**Description:** After a temping shift, Talent create and send an invoice to the dental office where they worked, so they can be paid by the dental office for work performed.  The “Invoice” table describes the details of Invoices created by Talent and sent to Dental Offices after a shift is completed.  This accounts for hours worked by the Talent, combined with their hourly rate and any unpaid time.

**Columns:**

	•	id (int): The unique ID of the Invoice record.

	•	jobID  (int): Indicates the ID of the temping shift corresponding to the invoice. (JOIN Job ON Job.id = Invoice.jobId).  

•	totalHours:  The number of hours worked by the Talent in the shift.

	•	totalUnpaidHours: The number of hours that were considered “unpaid time” during the shift, which could be lunch, breaks, etc.

	•	totalBillableHours:  This is the ‘totalHours’ minus ‘totalUnpaidHours’ which constitute the number of billable hours worked by the talent during the shift.

•	hourlyRate:  The dollar per hour amount earned by the Talent during the shift.

	•	totalInvoiceAmount:  This is the total amount invoiced to the dental office by the Talent, and is ‘totalBillableHours’ multiplied by ‘hourlyRate’.

	•	createdOn (datetime): This is the timestamp of when the invoice was created.

**TABLE JOIN Relationships**

	•	Job.location &lt;-> Location.id

	•	Job.hygienistId &lt;-> Hygienist.id

	•	User.hygienistId &lt;-> Hygienist.id

	•	PartialOffer.jobId &lt;-> Job.id

	•	PartialOffer.hygienistId &lt;-> Hygienist.id

	•	DentistCancelled.jobId &lt;-> Job.id

	•	DentistCancelled.locationId &lt;-> Location.id

	•	HygienistCancelled.hygienistId &lt;-> Hygienist.id

	•	Invoice.jobId &lt;-> Job.id

	•	User.dentistId &lt;-> Dentist.id

	•	Location.dentistId &lt;-> Dentist.id

	•	BlockedHygienist.hygienistId &lt;-> Hygienist.id

•	RoleMapping.principalId &lt;-> User.id

•	hireJob.id &lt;-> JobApplications.hireJobId

•	hireJob.locationId &lt;-> Location.id

•	JobApplications.hygienistId &lt;-> Hygienist.id

	•	BlockedDentist.locationId &lt;-> Location.id

•	Invoice.jobId &lt;> Job.id

```

---

## File: src/server/proxy.js

```javascript
const express = require('express');
const cors = require('cors');
const axios = require('axios');
require('dotenv').config();
const fs = require('fs').promises;
const path = require('path');
const { generateSystemPrompt } = require('../prompts/systemPrompt');

const app = express();
app.use(cors());
app.use(express.json());

const JIRA_API_BASE_URL = process.env.REACT_APP_JIRA_API_URL;
const JIRA_API_TOKEN = process.env.REACT_APP_JIRA_API_TOKEN;
const JIRA_EMAIL = process.env.REACT_APP_JIRA_EMAIL;

app.get('/api/jira/ticket/:ticketNumber', async (req, res) => {
  try {
    console.log('JIRA API URL:', JIRA_API_BASE_URL);
    console.log('Ticket Number:', req.params.ticketNumber);
    console.log('Auth Token Present:', !!JIRA_API_TOKEN);
    
    if (!JIRA_API_BASE_URL || !JIRA_API_TOKEN) {
      throw new Error('Missing required JIRA environment variables');
    }

    const authToken = Buffer.from(`${JIRA_EMAIL}:${JIRA_API_TOKEN}`).toString('base64');

    const response = await axios.get(
      `${JIRA_API_BASE_URL}/rest/api/2/issue/${req.params.ticketNumber}`,
      {
        headers: {
          'Authorization': `Basic ${authToken}`,
          'Content-Type': 'application/json',
        }
      }
    );
    res.json(response.data);
  } catch (error) {
    console.error('JIRA API Error:', {
      message: error.message,
      response: error.response?.data,
      status: error.response?.status
    });
    
    res.status(error.response?.status || 500).json({ 
      error: 'Failed to fetch Jira ticket details',
      details: error.response?.data || error.message
    });
  }
});

app.post('/api/local/directory', async (req, res) => {
  try {
    const { rootPath } = req.body;
    
    if (!isPathSafe(rootPath)) {
      return res.status(403).json({ 
        success: false, 
        error: 'Access to this directory is not allowed for security reasons' 
      });
    }

    const items = await fs.readdir(rootPath, { withFileTypes: true });
    
    const dirStructure = await Promise.all(items.map(async (item) => {
      const fullPath = path.join(rootPath, item.name);
      return {
        id: fullPath,
        name: item.name,
        isDirectory: item.isDirectory(),
        children: item.isDirectory() ? await readDirRecursive(fullPath) : null
      };
    }));

    res.json({ success: true, data: dirStructure });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: `Failed to read directory: ${error.message}` 
    });
  }
});

app.post('/api/local/file', async (req, res) => {
  try {
    const { filePath } = req.body;

    if (!isPathSafe(filePath)) {
      return res.status(403).json({ 
        success: false, 
        error: 'Access to this file is not allowed for security reasons' 
      });
    }

    const content = await fs.readFile(filePath, 'utf8');
    res.json({ success: true, content });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: `Failed to read file: ${error.message}` 
    });
  }
});

app.post('/api/concatenate-files', async (req, res) => {
  try {
    const { files, prNumber } = req.body;

    if (!Array.isArray(files) || files.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'No files selected for concatenation'
      });
    }

    // Read and concatenate all files
    const fileContents = await Promise.all(
      files.map(async (filePath) => {
        try {
          const content = await fs.readFile(filePath, 'utf8');
          const fileName = path.basename(filePath);
          return `\n\n# File: ${fileName}\n\`\`\`\n${content}\n\`\`\``;
        } catch (err) {
          console.error(`Error reading file ${filePath}:`, err);
          return `\n\n# Error reading file: ${filePath}\n`;
        }
      })
    );

    const concatenatedContent = fileContents.join('\n');

    res.json({
      success: true,
      data: concatenatedContent
    });
  } catch (error) {
    console.error('Error concatenating files:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Failed to concatenate files'
    });
  }
});

app.post('/api/generate-review', async (req, res) => {
  try {
    const { jiraTicket, githubPR, concatenatedFiles, referenceFiles } = req.body;
    const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;
    const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent";

    if (!concatenatedFiles) {
      return res.status(400).json({
        success: false,
        error: 'No files provided for review'
      });
    }

    // Generate the prompt
    const promptString = generateSystemPrompt({
      jiraTicket,
      githubPR,
      concatenatedFiles,
      additionalFiles: referenceFiles,
    });

    // Call Gemini API
    const geminiResponse = await axios.post(
      `${GEMINI_API_URL}?key=${GEMINI_API_KEY}`,
      {
        contents: [{
          parts: [{
            text: promptString
          }]
        }],
        generationConfig: {
          temperature: 0.3,
          topK: 40,
          topP: 0.8,
        }
      },
      {
        headers: {
          'Content-Type': 'application/json',
        }
      }
    );

    // Safely extract the generated text
    const generatedText = geminiResponse.data?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!generatedText) {
      throw new Error('Unexpected response format from Gemini API');
    }

    res.json({
      success: true,
      review: generatedText
    });
  } catch (error) {
    console.error('Error generating review:', error);
    res.status(error.response?.status || 500).json({
      success: false,
      error: error.message || 'Failed to generate review'
    });
  }
});

// Helper function for recursive directory reading
async function readDirRecursive(dirPath) {
  const items = await fs.readdir(dirPath, { withFileTypes: true });
  const result = await Promise.all(items.map(async (item) => {
    const fullPath = path.join(dirPath, item.name);
    return {
      id: fullPath,
      name: item.name,
      isDirectory: item.isDirectory(),
      children: item.isDirectory() ? await readDirRecursive(fullPath) : null
    };
  }));
  return result;
}

function isPathSafe(filePath) {
  // Prevent reading sensitive directories
  const sensitivePatterns = [
    /\/\.git\//,
    /\/node_modules\//,
    /\/\.env/,
    /\/\.ssh\//,
    /\/\.aws\//
  ];
  
  return !sensitivePatterns.some(pattern => pattern.test(filePath));
}

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Proxy server running on port ${PORT}`);
}); 
```

---

## File: src/server/package.json

```text
{
  "name": "server",
  "version": "1.0.0",
  "main": "proxy.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "axios": "^1.7.9",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2"
  }
}

```

---

## File: src/utils/helpers.ts

```typescript
export {};

```

---

## File: src/utils/storage.ts

```typescript
import { PRDetails } from '../types';

export const STORAGE_KEYS = {
  GITHUB_PRS: 'githubPRs',
  REVIEW_RESULT: 'reviewResult',
  SELECTED_FILES: 'selectedFiles',
} as const;

export const saveGitHubPRs = (prs: PRDetails) => {
  localStorage.setItem(STORAGE_KEYS.GITHUB_PRS, JSON.stringify(prs));
};

export const getGitHubPRs = (): PRDetails | null => {
  const stored = localStorage.getItem(STORAGE_KEYS.GITHUB_PRS);
  return stored ? JSON.parse(stored) : null;
}; 
```

---

## File: src/components/FileTree.tsx

```text
// src/components/FileTree.tsx

import React, { useEffect, useState } from 'react';
import { SimpleTreeView } from '@mui/x-tree-view/SimpleTreeView';
import { TreeItem } from '@mui/x-tree-view/TreeItem';
import { ExpandMore, ChevronRight, Folder, InsertDriveFile } from '@mui/icons-material';
import { Box, Checkbox, CircularProgress, Typography } from '@mui/material';

import { FileNode, GitHubFile } from '../types';
import { readLocalDirectory } from '../services/LocalFileService';

interface FileTreeProps {
  rootPath: string;
  onSelect: (files: string[]) => void;
  changedFiles?: GitHubFile[];
  onError: (error: Error) => void;
}

interface TreeNode {
  id: string;
  name: string;
  isDirectory: boolean;
  children?: TreeNode[];
}

/**
 * Renders a TreeView of the local file system starting at rootPath.
 * Allows checkbox selection of files/folders. "changedFiles" are pre-selected.
 */
export const FileTree: React.FC<FileTreeProps> = ({
  rootPath,
  onSelect,
  changedFiles = [],
  onError
}) => {
  const [selectedItems, setSelectedItems] = useState<string[]>([]);
  const [treeData, setTreeData] = useState<TreeNode | null>(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    const fetchDirectory = async () => {
      if (!rootPath) return;
      
      setLoading(true);
      try {
        const response = await fetch('/api/local/directory', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ rootPath }),
        });

        if (!response.ok) {
          throw new Error('Failed to fetch directory structure');
        }

        const data = await response.json();
        if (data.success && data.data) {
          setTreeData({
            id: rootPath,
            name: rootPath.split('/').pop() || rootPath,
            isDirectory: true,
            children: data.data
          });
        } else {
          throw new Error(data.error || 'Failed to load directory structure');
        }
      } catch (error) {
        onError(error instanceof Error ? error : new Error('Unknown error occurred'));
      } finally {
        setLoading(false);
      }
    };

    fetchDirectory();
  }, [rootPath, onError]);

  // New helper function to get all child node IDs
  const getAllChildIds = (node: TreeNode): string[] => {
    let ids: string[] = [node.id];
    if (node.children) {
      node.children.forEach(child => {
        ids = [...ids, ...getAllChildIds(child)];
      });
    }
    return ids;
  };

  // New helper function to find a node by ID
  const findNode = (id: string, node: TreeNode): TreeNode | null => {
    if (node.id === id) return node;
    if (node.children) {
      for (const child of node.children) {
        const found = findNode(id, child);
        if (found) return found;
      }
    }
    return null;
  };

  // Helper to get all child file paths from a directory
  const getAllChildPaths = (node: TreeNode): string[] => {
    let paths: string[] = [];
    if (!node.isDirectory) {
      paths.push(node.id);
    } else if (node.children) {
      node.children.forEach(child => {
        paths = [...paths, ...getAllChildPaths(child)];
      });
    }
    return paths;
  };

  // Updated selection handler
  const handleSelectedChange = (nodeId: string) => {
    setSelectedItems(prev => {
      const node = treeData ? findNode(nodeId, treeData) : null;
      if (!node) return prev;

      const newSelection = new Set(prev);
      const isCurrentlySelected = newSelection.has(nodeId);
      
      // Get all child paths if this is a directory
      const pathsToToggle = node.isDirectory ? getAllChildPaths(node) : [nodeId];
      
      pathsToToggle.forEach(path => {
        if (isCurrentlySelected) {
          newSelection.delete(path);
        } else {
          newSelection.add(path);
        }
      });

      const result = Array.from(newSelection);
      onSelect(result);
      return result;
    });
  };

  const getNodeIcon = (node: TreeNode) => {
    return node.isDirectory ? <Folder color="primary" /> : <InsertDriveFile />;
  };

  const renderTree = (node: TreeNode) => {
    if (!node || !node.id) return null;

    return (
      <TreeItem
        key={node.id}
        itemId={node.id}
        label={
          <Box sx={{ display: 'flex', alignItems: 'center', py: 0.5 }}>
            <Checkbox
              checked={selectedItems.includes(node.id)}
              onChange={() => handleSelectedChange(node.id)}
              onClick={(e) => e.stopPropagation()}
              size="small"
            />
            {getNodeIcon(node)}
            <Typography sx={{ ml: 1 }}>
              {node.name}
            </Typography>
          </Box>
        }
        sx={{
          '& .MuiTreeItem-content': {
            padding: '4px 0'
          }
        }}
      >
        {Array.isArray(node.children)
          ? node.children.map((child) => renderTree(child))
          : null}
      </TreeItem>
    );
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" p={2}>
        <CircularProgress />
      </Box>
    );
  }

  if (!treeData) {
    return null;
  }

  return (
    <Box sx={{ border: '1px solid #e0e0e0', borderRadius: 1, p: 1 }}>
      <SimpleTreeView
        multiSelect
        selectedItems={selectedItems}
        onSelectedItemsChange={(_, itemIds) => {
          if (itemIds.length > 0) {
            handleSelectedChange(itemIds[0]);
          }
        }}
        aria-label="file system navigator"
        slots={{
          expandIcon: ChevronRight,
          collapseIcon: ExpandMore
        }}
        sx={{
          height: '400px',
          flexGrow: 1,
          maxWidth: '100%',
          overflowY: 'auto',
          '& .MuiTreeItem-root': {
            '& .MuiTreeItem-content': {
              padding: '2px 0'
            }
          }
        }}
      >
        {renderTree(treeData)}
      </SimpleTreeView>
    </Box>
  );
};

export default FileTree;

```

---

## File: src/components/ReviewWizard.tsx

```text
export {};

```

---

## File: src/components/Steps/FileSelectionStep.tsx

```text
// src/components/Steps/FileSelectionStep.tsx

import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  Button,
  CircularProgress,
  Alert,
  TextField,
} from '@mui/material';

import { FileTree } from '../FileTree';
import { concatenateFiles } from '../../services/FileService';
import { GitHubPR, GitHubFile } from '../../types';

interface FileTreeProps {
  rootPath: string;
  onSelect: (files: string[]) => void;
  changedFiles: GitHubFile[];
  onError: (error: Error) => void;
}

const FileSelectionStep: React.FC = () => {
  const navigate = useNavigate();
  const [rootPath, setRootPath] = useState<string>('');
  const [showTree, setShowTree] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [pr, setPR] = useState<GitHubPR | null>(null);
  const [concatenatedContent, setConcatenatedContent] = useState<string>('');

  const changedFiles = useMemo(() => pr?.changedFiles || [], [pr]);

  useEffect(() => {
    // Load PR data from localStorage
    try {
      const prData = localStorage.getItem('githubPRs');
      if (prData) {
        setPR(JSON.parse(prData));
      }
    } catch (err) {
      console.error('Error loading PR data:', err);
    }
  }, []);

  const handlePathChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setRootPath(e.target.value);
    setShowTree(false); // Hide tree when path changes
    setError(null);
  };

  const handleFetchDirectory = () => {
    setLoading(true);
    setError(null);
    
    try {
      const trimmedPath = rootPath.trim();
      if (!trimmedPath) {
        throw new Error('Please enter a valid root directory path');
      }

      console.log('Fetching directory for path:', trimmedPath);
      setShowTree(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Invalid path');
      setShowTree(false);
    } finally {
      setLoading(false);
    }
  };

  const handleFileSelect = (files: string[]) => {
    console.log('Selected files:', files);
    setSelectedFiles(files);
  };

  const handleConcatenate = async () => {
    if (selectedFiles.length === 0) {
      setError('Please select at least one file');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const prNumber = pr?.number?.toString() || '';
      
      const response = await fetch('/api/concatenate-files', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          files: selectedFiles,
          prNumber
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to concatenate files: ${response.statusText}`);
      }

      const result = await response.json();

      if (result.success && result.data) {
        setConcatenatedContent(result.data);
      } else {
        throw new Error(result.error || 'Failed to concatenate files');
      }
    } catch (err) {
      console.error('Error processing files:', err);
      setError(err instanceof Error ? err.message : 'Failed to process selected files');
    } finally {
      setLoading(false);
    }
  };

  const handleNext = () => {
    if (concatenatedContent) {
      localStorage.setItem('concatenatedFiles', concatenatedContent);
      navigate('/additional-files');
    }
  };

  return (
    <Paper elevation={3} sx={{ p: 4, maxWidth: 800, mx: 'auto' }}>
      <Typography variant="h5" component="h1" gutterBottom>
        Step 3: Select Files for Review
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Box component="form" sx={{ mb: 3 }}>
        <Typography variant="subtitle1" gutterBottom>
          Root Directory Path
        </Typography>
        <TextField
          fullWidth
          value={rootPath}
          onChange={handlePathChange}
          placeholder="/path/to/your/project"
          sx={{ mb: 2 }}
        />
        <Button
          variant="contained"
          onClick={handleFetchDirectory}
          disabled={loading || !rootPath.trim()}
        >
          {loading ? <CircularProgress size={24} /> : 'Fetch Directory'}
        </Button>
      </Box>

      {showTree && !error && (
        <Box sx={{ mb: 3, height: '400px', overflow: 'auto' }}>
          <FileTree
            rootPath={rootPath}
            onSelect={handleFileSelect}
            changedFiles={changedFiles}
            onError={(error: Error) => setError(error.message)}
          />
        </Box>
      )}

      <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
        <Button
          variant="outlined"
          onClick={() => navigate('/github-pr')}
          disabled={loading}
        >
          Back
        </Button>
        <Button
          variant="contained"
          onClick={handleConcatenate}
          disabled={loading || selectedFiles.length === 0}
        >
          {loading ? <CircularProgress size={20} /> : 'Concatenate Files'}
        </Button>
        <Button
          variant="contained"
          onClick={handleNext}
          disabled={loading || !concatenatedContent}
        >
          Next
        </Button>
      </Box>

      {/* Display concatenated content */}
      {concatenatedContent && (
        <Box sx={{ mt: 2 }}>
          <Typography variant="body2" fontWeight="bold">
            Concatenated Files:
          </Typography>
          <pre style={{ 
            background: '#f5f5f5', 
            padding: '1rem',
            borderRadius: '4px',
            overflow: 'auto',
            maxHeight: '400px'
          }}>
            {concatenatedContent}
          </pre>
        </Box>
      )}
    </Paper>
  );
};

export default FileSelectionStep;


```

---

## File: src/components/Steps/GitHubPRStep.tsx

```text
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Paper,
  Typography,
  TextField,
  Button,
  Box,
  FormControlLabel,
  Checkbox,
  Alert,
  CircularProgress
} from '@mui/material';
import { getPullRequestDetails } from '../../services/GitHubService';
import { PRDetails } from '../../types';
import { STORAGE_KEYS, saveGitHubPRs, getGitHubPRs } from '../../utils/storage';

const REPOS = {
  frontend: {
    owner: 'drjyounger',
    name: 'tempstars-app'
  },
  backend: {
    owner: 'drjyounger',
    name: 'tempstars-api'
  }
};

const GitHubPRStep: React.FC = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const [prs, setPRs] = useState({
    frontend: { number: '', selected: false },
    backend: { number: '', selected: false }
  });

  const [prDetails, setPrDetails] = useState<PRDetails>({
    frontend: null,
    backend: null
  });

  const handleFetchPRs = async () => {
    console.log('[client] [Step2:GitHubPR] Starting PR fetch with:', prs);
    setLoading(true);
    setError(null);
    
    try {
      const updatedPRDetails: PRDetails = {
        frontend: null,
        backend: null
      };
      const promises = [];

      if (prs.frontend.selected && prs.frontend.number) {
        console.log(`[client] [Step2:GitHubPR] Fetching frontend PR #${prs.frontend.number}...`);
        promises.push(
          getPullRequestDetails(
            parseInt(prs.frontend.number), 
            REPOS.frontend.owner, 
            REPOS.frontend.name
          ).then(result => {
            if (result.success && result.data) {
              updatedPRDetails.frontend = result.data;
            } else {
              throw new Error(`Frontend PR Error: ${result.error}`);
            }
          })
        );
      }

      if (prs.backend.selected && prs.backend.number) {
        console.log(`[client] [Step2:GitHubPR] Fetching backend PR #${prs.backend.number}...`);
        promises.push(
          getPullRequestDetails(
            parseInt(prs.backend.number),
            REPOS.backend.owner,
            REPOS.backend.name
          ).then(result => {
            if (result.success && result.data) {
              updatedPRDetails.backend = result.data;
            } else {
              throw new Error(`Backend PR Error: ${result.error}`);
            }
          })
        );
      }

      if (promises.length === 0) {
        throw new Error('Please select at least one PR to review');
      }

      await Promise.all(promises);
      console.log('[client] [Step2:GitHubPR] Final PR Details:', updatedPRDetails);
      setPrDetails(updatedPRDetails);

    } catch (err) {
      console.error('[client] [Step2:GitHubPR] Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch PR details');
    } finally {
      setLoading(false);
    }
  };

  const handleNext = () => {
    if (prDetails.frontend || prDetails.backend) {
      saveGitHubPRs(prDetails);
      navigate('/file-selection');
    }
  };

  const handleInputChange = (repo: 'frontend' | 'backend', value: string) => {
    setPRs(prev => ({
      ...prev,
      [repo]: { ...prev[repo], number: value }
    }));
  };

  const handleCheckboxChange = (repo: 'frontend' | 'backend') => {
    setPRs(prev => ({
      ...prev,
      [repo]: { ...prev[repo], selected: !prev[repo].selected }
    }));
  };

  return (
    <Paper elevation={3} sx={{ p: 4, maxWidth: 600, mx: 'auto' }}>
      <Typography variant="h5" component="h1" gutterBottom>
        Step 2: GitHub Pull Requests
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Box sx={{ mb: 3 }}>
        <FormControlLabel
          control={
            <Checkbox
              checked={prs.frontend.selected}
              onChange={() => handleCheckboxChange('frontend')}
            />
          }
          label="Front End (tempstars-app)"
        />
        {prs.frontend.selected && (
          <TextField
            fullWidth
            label="PR Number"
            value={prs.frontend.number}
            onChange={(e) => handleInputChange('frontend', e.target.value)}
            sx={{ mt: 1 }}
            disabled={loading}
          />
        )}
      </Box>

      <Box sx={{ mb: 3 }}>
        <FormControlLabel
          control={
            <Checkbox
              checked={prs.backend.selected}
              onChange={() => handleCheckboxChange('backend')}
            />
          }
          label="Back End (tempstars-api)"
        />
        {prs.backend.selected && (
          <TextField
            fullWidth
            label="PR Number"
            value={prs.backend.number}
            onChange={(e) => handleInputChange('backend', e.target.value)}
            sx={{ mt: 1 }}
            disabled={loading}
          />
        )}
      </Box>

      <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
        <Button
          variant="outlined"
          onClick={() => navigate('/jira-ticket')}
          disabled={loading}
        >
          Back
        </Button>
        <Button
          variant="contained"
          onClick={handleFetchPRs}
          disabled={loading || (!prs.frontend.selected && !prs.backend.selected)}
        >
          {loading ? <CircularProgress size={20} /> : 'Fetch PR(s)'}
        </Button>
        <Button
          variant="contained"
          onClick={handleNext}
          disabled={loading || (!prDetails.frontend && !prDetails.backend)}
        >
          Next
        </Button>
      </Box>

      {/* Display fetched PR details */}
      {(prDetails.frontend || prDetails.backend) && (
        <Box sx={{ mt: 2 }}>
          {prDetails.frontend && (
            <Box sx={{ mb: 2 }}>
              <Typography variant="body2" fontWeight="bold">
                Frontend PR #{prDetails.frontend.number}:
              </Typography>
              <pre style={{ 
                background: '#f5f5f5', 
                padding: '1rem',
                borderRadius: '4px',
                overflow: 'auto',
                maxHeight: '300px'
              }}>
                {JSON.stringify(prDetails.frontend, null, 2)}
              </pre>
            </Box>
          )}
          {prDetails.backend && (
            <Box sx={{ mb: 2 }}>
              <Typography variant="body2" fontWeight="bold">
                Backend PR #{prDetails.backend.number}:
              </Typography>
              <pre style={{ 
                background: '#f5f5f5', 
                padding: '1rem',
                borderRadius: '4px',
                overflow: 'auto',
                maxHeight: '300px'
              }}>
                {JSON.stringify(prDetails.backend, null, 2)}
              </pre>
            </Box>
          )}
        </Box>
      )}
    </Paper>
  );
};

// Reading data:
const savedPRs = getGitHubPRs();

export default GitHubPRStep; 
```

---

## File: src/components/Steps/Step6ReviewResults.tsx

```text
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  Button,
  Alert,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Divider,
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';

interface ReviewResult {
  review: string;
  suggestions: string[];
  score: number;
}

interface Sections {
  [key: string]: string;
  summary: string;
  criticalIssues: string;
  recommendations: string;
  highlights: string;
  breakdown: string;
}

const Step6ReviewResults: React.FC = () => {
  const navigate = useNavigate();
  const [reviewData, setReviewData] = useState<ReviewResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    try {
      const storedReview = localStorage.getItem('reviewResult');
      if (!storedReview) {
        throw new Error('No review data found');
      }
      setReviewData(JSON.parse(storedReview));
    } catch (err) {
      setError('Failed to load review results');
      console.error(err);
    }
  }, []);

  // Parse review sections from the text
  const parseSections = (review: string) => {
    const sections: Sections = {
      summary: '',
      criticalIssues: '',
      recommendations: '',
      highlights: '',
      breakdown: ''
    };

    let currentSection = '';
    const lines = review.split('\n');

    for (const line of lines) {
      if (line.includes('1. SUMMARY')) {
        currentSection = 'summary';
      } else if (line.includes('2. CRITICAL ISSUES')) {
        currentSection = 'criticalIssues';
      } else if (line.includes('3. RECOMMENDATIONS')) {
        currentSection = 'recommendations';
      } else if (line.includes('4. POSITIVE HIGHLIGHTS')) {
        currentSection = 'highlights';
      } else if (line.includes('5. DETAILED BREAKDOWN')) {
        currentSection = 'breakdown';
      } else if (currentSection) {
        sections[currentSection] += line + '\n';
      }
    }

    return sections;
  };

  const defaultSections: Sections = {
    summary: '',
    criticalIssues: '',
    recommendations: '',
    highlights: '',
    breakdown: ''
  };

  const sections: Sections = reviewData ? parseSections(reviewData.review) : defaultSections;

  if (error) {
    return (
      <Paper elevation={3} sx={{ p: 4, maxWidth: 800, mx: 'auto' }}>
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
        <Button variant="contained" onClick={() => navigate('/submit-review')}>
          Back to Review Submission
        </Button>
      </Paper>
    );
  }

  return (
    <Paper elevation={3} sx={{ p: 4, maxWidth: 800, mx: 'auto' }}>
      <Typography variant="h5" component="h1" gutterBottom>
        Code Review Results
      </Typography>

      {sections && (
        <Box sx={{ mt: 3 }}>
          <Accordion defaultExpanded>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography variant="h6">Summary</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                {sections.summary}
              </Typography>
            </AccordionDetails>
          </Accordion>

          <Accordion>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography variant="h6" color="error">Critical Issues</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                {sections.criticalIssues}
              </Typography>
            </AccordionDetails>
          </Accordion>

          <Accordion>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography variant="h6" color="primary">Recommendations</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                {sections.recommendations}
              </Typography>
            </AccordionDetails>
          </Accordion>

          <Accordion>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography variant="h6" color="success.main">Positive Highlights</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                {sections.highlights}
              </Typography>
            </AccordionDetails>
          </Accordion>

          <Accordion>
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
              <Typography variant="h6">Detailed Breakdown</Typography>
            </AccordionSummary>
            <AccordionDetails>
              <Typography component="pre" sx={{ whiteSpace: 'pre-wrap' }}>
                {sections.breakdown}
              </Typography>
            </AccordionDetails>
          </Accordion>
        </Box>
      )}

      <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
        <Button
          variant="outlined"
          onClick={() => navigate('/submit-review')}
        >
          Back
        </Button>
        <Button
          variant="contained"
          onClick={() => {
            localStorage.clear(); // Clear wizard data
            navigate('/jira-ticket');
          }}
        >
          Start New Review
        </Button>
      </Box>
    </Paper>
  );
};

export default Step6ReviewResults;

```

---

## File: src/components/Steps/JiraTicketStep.tsx

```text
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  TextField,
  Button,
  Typography,
  Paper,
  CircularProgress,
  Alert,
} from '@mui/material';
import { getTicketDetails } from '../../services/JiraService';
import { JiraTicket } from '../../types';

const JiraTicketStep: React.FC = () => {
  const navigate = useNavigate();
  const [ticketNumber, setTicketNumber] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [ticket, setTicket] = useState<JiraTicket | null>(null);

  const handleFetchTicket = async () => {
    setError(null);
    setLoading(true);

    console.log('[client] [Step1:JiraTicket] Attempting to fetch Jira ticket:', ticketNumber);

    try {
      const response = await getTicketDetails(ticketNumber);
      
      if (response.success && response.data) {
        console.log('[client] [Step1:JiraTicket] Successfully retrieved Jira ticket data:', response.data);
        setTicket(response.data);
      } else {
        setError(response.error || 'Failed to fetch ticket details');
      }
    } catch (err) {
      console.error('[client] [Step1:JiraTicket] Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch ticket details');
    } finally {
      setLoading(false);
    }
  };

  const handleNext = () => {
    if (ticket) {
      localStorage.setItem('jiraTicket', JSON.stringify(ticket));
      console.log('[client] [Step1:JiraTicket] Stored ticket in localStorage. Navigating to GitHub PR step.');
      navigate('/github-pr');
    }
  };

  return (
    <Paper elevation={3} sx={{ p: 4, maxWidth: 600, mx: 'auto' }}>
      <Typography variant="h5" component="h1" gutterBottom>
        Step 1: Enter Jira Ticket
      </Typography>
      
      <form onSubmit={(e) => { e.preventDefault(); handleNext(); }}>
        <Box sx={{ mb: 3 }}>
          <TextField
            fullWidth
            label="Jira Ticket Number"
            value={ticketNumber}
            onChange={(e) => setTicketNumber(e.target.value)}
            placeholder="e.g., PROJ-123"
            disabled={loading}
            error={!!error}
            helperText={error}
          />
        </Box>

        <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
          <Button
            variant="contained"
            onClick={handleFetchTicket}
            disabled={!ticketNumber.trim() || loading}
          >
            {loading ? <CircularProgress size={20} /> : 'Fetch Ticket'}
          </Button>
          <Button
            variant="contained"
            onClick={handleNext}
            disabled={!ticket || loading}
          >
            Next
          </Button>
        </Box>

        {ticket && (
          <Box sx={{ mt: 2, whiteSpace: 'pre-wrap' }}>
            <Typography variant="body2" fontWeight="bold">
              Fetched Jira Ticket:
            </Typography>
            <pre style={{ 
              background: '#f5f5f5', 
              padding: '1rem',
              borderRadius: '4px',
              overflow: 'auto',
              maxHeight: '300px'
            }}>
              {JSON.stringify(ticket, null, 2)}
            </pre>
          </Box>
        )}
      </form>
    </Paper>
  );
};

export default JiraTicketStep; 
```

---

## File: src/components/Steps/AdditionalFilesStep.tsx

```text
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  Button,
  FormGroup,
  FormControlLabel,
  Checkbox,
  Alert
} from '@mui/material';

interface ReferenceFile {
  id: string;
  name: string;
  type: 'coding-standard' | 'schema' | 'reference' | 'business-context';
  path: string;
}

const REFERENCE_FILES: ReferenceFile[] = [
  {
    id: 'coding-standards',
    name: 'Design & Coding Standards',
    type: 'coding-standard',
    path: '/references/designCodingStandards.md'
  },
  {
    id: 'db-schema',
    name: 'Database Schema',
    type: 'schema',
    path: '/references/databaseSchema.md'
  },
  {
    id: 'business-context',
    name: 'Business Context',
    type: 'business-context',
    path: '/references/businessContext.md'
  }
];

const AdditionalFilesStep: React.FC = () => {
  const navigate = useNavigate();
  const [selectedFiles, setSelectedFiles] = useState<Set<string>>(new Set());
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Verify we have required data from previous steps
    const concatenatedFiles = localStorage.getItem('concatenatedFiles');
    if (!concatenatedFiles) {
      navigate('/file-selection');
    }
  }, [navigate]);

  const handleFileToggle = (fileId: string) => {
    const newSelected = new Set(selectedFiles);
    if (newSelected.has(fileId)) {
      newSelected.delete(fileId);
    } else {
      newSelected.add(fileId);
    }
    setSelectedFiles(newSelected);
  };

  const handleNext = () => {
    try {
      // Store selected reference files
      localStorage.setItem('referenceFiles', JSON.stringify(Array.from(selectedFiles)));
      navigate('/submit-review');
    } catch (err) {
      setError('Failed to save selected reference files');
    }
  };

  return (
    <Paper elevation={3} sx={{ p: 4, maxWidth: 800, mx: 'auto' }}>
      <Typography variant="h5" component="h1" gutterBottom>
        Step 4: Select Additional Reference Files
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <FormGroup sx={{ mb: 3 }}>
        {REFERENCE_FILES.map((file) => (
          <FormControlLabel
            key={file.id}
            control={
              <Checkbox
                checked={selectedFiles.has(file.id)}
                onChange={() => handleFileToggle(file.id)}
              />
            }
            label={`${file.name} (${file.type})`}
          />
        ))}
      </FormGroup>

      <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 3 }}>
        <Button
          variant="outlined"
          onClick={() => navigate('/file-selection')}
        >
          Back
        </Button>
        <Button
          variant="contained"
          onClick={handleNext}
        >
          Next
        </Button>
      </Box>
    </Paper>
  );
};

export default AdditionalFilesStep; 
```

---

## File: src/components/Steps/ReviewSubmissionStep.tsx

```text
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Paper,
  Typography,
  Button,
  Box,
  Alert,
  CircularProgress
} from '@mui/material';
import { generateCodeReview } from '../../services/LLMService';
import { generateSystemPrompt } from '../../prompts/systemPrompt';

interface JiraTicket {
  key: string;
  // Add other required Jira ticket fields
}

interface GithubPR {
  number: string;
  title: string;
  description: string;
  changedFiles: any[]; // Consider making this more specific
}

const ReviewSubmissionStep: React.FC = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [promptPreview, setPromptPreview] = useState<string>('');

  const validateData = (
    jiraTicket: any,
    githubPR: any,
    concatenatedFiles: string,
    referenceFiles: string[]
  ): { isValid: boolean; error?: string } => {
    // Validate Jira Ticket
    if (!jiraTicket?.key) {
      return { isValid: false, error: 'Invalid Jira ticket data. Please return to Step 1.' };
    }

    // Validate GitHub PR
    if (!githubPR?.number || !githubPR?.title || !githubPR?.changedFiles) {
      return { isValid: false, error: 'Invalid GitHub PR data. Please return to Step 2.' };
    }

    // Validate Concatenated Files
    if (!concatenatedFiles || concatenatedFiles.length === 0) {
      return { isValid: false, error: 'No files selected for review. Please return to Step 3.' };
    }

    // Reference files can be empty, but should be an array
    if (!Array.isArray(referenceFiles)) {
      return { isValid: false, error: 'Invalid reference files format. Please return to Step 4.' };
    }

    return { isValid: true };
  };

  const handleSubmit = async () => {
    setLoading(true);
    setError(null);

    console.log('[client] [Step5:ReviewSubmission] Collecting stored data for LLM submission...');
    
    try {
      const jiraTicket = JSON.parse(localStorage.getItem('jiraTicket') || '{}');
      const githubPR = JSON.parse(localStorage.getItem('githubPRs') || '{}');
      const concatenatedFiles = localStorage.getItem('concatenatedFiles') || '';
      const referenceFiles = JSON.parse(localStorage.getItem('referenceFiles') || '[]');

      console.log('[client] [Step5:ReviewSubmission] Data collected:', {
        jiraTicket,
        githubPR,
        concatenatedFilesLength: concatenatedFiles.length,
        referenceFiles
      });

      console.log('[client] [Step5:ReviewSubmission] Sending data to LLM...');
      const review = await generateCodeReview({
        jiraTicket,
        githubPR,
        concatenatedFiles,
        referenceFiles
      });

      if (review.success) {
        console.log('[client] [Step5:ReviewSubmission] Successfully received code review. Storing and navigating to results...');
        localStorage.setItem('reviewResult', JSON.stringify({
          review: review.data,
          suggestions: [],
          score: 0
        }));
        navigate('/review-result');
      }
    } catch (err) {
      console.error('[client] [Step5:ReviewSubmission] Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to generate review');
    } finally {
      setLoading(false);
    }
  };

  const handlePreviewPrompt = () => {
    try {
      const jiraTicket = JSON.parse(localStorage.getItem('jiraTicket') || '{}');
      const githubPR = JSON.parse(localStorage.getItem('githubPRs') || '{}');
      const concatenatedFiles = localStorage.getItem('concatenatedFiles') || '';
      const referenceFiles = JSON.parse(localStorage.getItem('referenceFiles') || '[]');

      const promptString = generateSystemPrompt({
        jiraTicket,
        githubPR,
        concatenatedFiles,
        additionalFiles: referenceFiles
      });

      setPromptPreview(promptString);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to generate preview');
    }
  };

  return (
    <Paper elevation={3} sx={{ p: 4, maxWidth: 800, mx: 'auto' }}>
      <Typography variant="h5" component="h1" gutterBottom>
        Submit Code Review
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
        <Button
          variant="outlined"
          onClick={() => navigate('/additional-files')}
          disabled={loading}
        >
          Back
        </Button>
        <Button
          variant="contained"
          color="secondary"
          onClick={handlePreviewPrompt}
          disabled={loading}
        >
          Preview API Call
        </Button>
        <Button
          variant="contained"
          onClick={handleSubmit}
          disabled={loading}
        >
          {loading ? <CircularProgress size={20} /> : 'Submit Review'}
        </Button>
      </Box>

      {/* Display prompt preview */}
      {promptPreview && (
        <Box sx={{ mt: 2 }}>
          <Typography variant="body2" fontWeight="bold">
            API Call Preview:
          </Typography>
          <pre style={{ 
            background: '#f5f5f5', 
            padding: '1rem',
            borderRadius: '4px',
            overflow: 'auto',
            maxHeight: '500px'
          }}>
            {promptPreview}
          </pre>
        </Box>
      )}
    </Paper>
  );
};

export default ReviewSubmissionStep; 
```

---

## File: src/prompts/systemPrompt.js

```javascript
const generateSystemPrompt = ({
  jiraTicket,
  githubPR,
  concatenatedFiles,
  additionalFiles
}) => {
  const jiraKey = jiraTicket?.key || 'N/A';
  const prNumber = githubPR?.number || 'N/A';
  const prTitle = githubPR?.title || 'N/A';
  const prDescription = githubPR?.description || 'N/A';
  const changedFilesCount = githubPR?.changedFiles?.length || 0;

  return `You are an expert-level code reviewer for TempStars, a web and mobile based two-sided marketplace platform that connects dental offices with dental professionals for temping and hiring.

ROLE AND OBJECTIVE:
- You are tasked with providing comprehensive, actionable code reviews
- Your analysis should focus on code quality, security, performance, and alignment with business requirements
- You should identify potential bugs, edge cases, and areas for optimization
- You must ensure the code aligns with the provided database schema and coding standards.

Here is the Jira ticket information related to this task:
${JSON.stringify(jiraTicket || {}, null, 2)}

And here is the pull request information as related to this task:
${JSON.stringify(githubPR || {}, null, 2)}

And here are all the files related to this work:
${concatenatedFiles || ''}

Additional context files:
${(additionalFiles || []).join('\n')}

REVIEW CONTEXT:
1. Jira Ticket Details:
- Ticket: ${jiraKey}

2. GitHub Pull Request:
- PR #${prNumber}: ${prTitle}
- Description: ${prDescription}
- Changed Files: ${changedFilesCount} files modified

3. Below is a long concatenated file that contains all code related to the ticket, this includes the changed code but also other files that would be contextually related to the ticket. 
${concatenatedFiles || ''}

4. Additional Context:
${(additionalFiles || []).join('\n')}

REVIEW GUIDELINES:
1. Code Quality:
   - Identify any code smells or anti-patterns
   - Check for proper error handling
   - Verify proper typing and null checks
   - Assess code organization and modularity
   - Review naming conventions and code clarity

2. Database Considerations:
   - Verify proper use of database schema
   - Check for potential SQL injection vulnerabilities
   - Review query performance and optimization
   - Ensure proper handling of relationships between tables

3. Security:
   - Check for security vulnerabilities
   - Verify proper authentication/authorization
   - Review data validation and sanitization
   - Assess handling of sensitive information

4. Performance:
   - Identify potential performance bottlenecks
   - Review API call efficiency
   - Check for unnecessary re-renders in React components
   - Assess memory usage and potential leaks

5. Business Logic:
   - Verify implementation matches acceptance criteria
   - Check for proper handling of edge cases
   - Ensure business rules are correctly implemented
   - Verify proper error messaging for users

Please provide your review in the following structure:

1. SUMMARY
Brief overview of the changes and their impact

2. CRITICAL ISSUES
Any blocking issues that must be addressed

3. RECOMMENDATIONS
Suggested improvements categorized by:
- Security
- Performance
- Code Quality
- Business Logic
- Testing

4. POSITIVE HIGHLIGHTS
Well-implemented aspects of the code

5. DETAILED BREAKDOWN
File-by-file analysis of significant changes

Remember to be thorough but constructive in your feedback, providing specific examples and suggested solutions where applicable.`;
};

module.exports = { generateSystemPrompt }; 
```

---

## File: src/services/JiraService.ts

```typescript
import axios from 'axios';
import { JiraTicket, ApiResponse } from '../types';

const API_BASE_URL = 'http://localhost:3001/api';

export const getTicketDetails = async (ticketNumber: string): Promise<ApiResponse<JiraTicket>> => {
  try {
    const response = await axios.get(`${API_BASE_URL}/jira/ticket/${ticketNumber}`);
    const data = response.data;

    // Simplified ticket with only key, summary, and description
    const ticket: JiraTicket = {
      key: data.key,
      summary: data.fields.summary,
      description: data.fields.description || '',
    };

    return {
      success: true,
      data: ticket,
    };
  } catch (error: any) {
    console.error('Error fetching Jira ticket:', {
      message: error.message,
      response: error.response?.data
    });
    
    return {
      success: false,
      error: error.response?.data?.details || error.message || 'Failed to fetch Jira ticket details',
    };
  }
};

```

---

## File: src/services/GitHubService.ts

```typescript
import { Octokit } from '@octokit/rest';
import { GitHubPR, ApiResponse } from '../types';

const GITHUB_TOKEN = process.env.REACT_APP_GITHUB_TOKEN;
const REPO_OWNER = process.env.REACT_APP_GITHUB_OWNER;
const REPO_NAME = process.env.REACT_APP_GITHUB_REPO;

const octokit = new Octokit({
  auth: GITHUB_TOKEN,
});

export const getPullRequestDetails = async (
  prNumber: number,
  owner: string,
  repo: string
): Promise<ApiResponse<GitHubPR>> => {
  console.log('GitHub API Config:', {
    hasToken: !!GITHUB_TOKEN,
    owner,
    repo,
    prNumber
  });

  try {
    // Fetch PR details
    const { data: prData } = await octokit.pulls.get({
      owner,
      repo,
      pull_number: prNumber,
    });

    // Fetch PR files
    const { data: files } = await octokit.pulls.listFiles({
      owner,
      repo,
      pull_number: prNumber,
    });

    const pullRequest: GitHubPR = {
      number: prData.number,
      title: prData.title,
      description: prData.body || '',
      repo: { owner, name: repo },
      changedFiles: files.map(file => ({
        filename: file.filename,
        status: file.status as 'added' | 'modified' | 'removed',
        patch: file.patch,
      })),
      author: prData.user?.login,
      createdAt: prData.created_at,
      isMerged: Boolean(prData.merged_at),
      mergeable: prData.mergeable ?? undefined,
      labels: prData.labels?.map(label => label.name) || [],
    };

    return {
      success: true,
      data: pullRequest,
    };
  } catch (error) {
    console.error('Error fetching GitHub PR:', error);
    return {
      success: false,
      error: 'Failed to fetch GitHub pull request details',
    };
  }
};

export const getFileContent = async (filePath: string, ref: string): Promise<ApiResponse<string>> => {
  try {
    const { data } = await octokit.repos.getContent({
      owner: REPO_OWNER!,
      repo: REPO_NAME!,
      path: filePath,
      ref,
    });

    if ('content' in data) {
      const content = Buffer.from(data.content, 'base64').toString();
      return {
        success: true,
        data: content,
      };
    }

    throw new Error('Not a file');
  } catch (error) {
    console.error('Error fetching file content:', error);
    return {
      success: false,
      error: 'Failed to fetch file content',
    };
  }
};

```

---

## File: src/services/LocalFileService.ts

```typescript
// src/services/LocalFileService.ts

import { FileNode } from '../types';

interface DirectoryResponse {
    path: string;
    type: 'file' | 'directory';
    children?: DirectoryResponse[];
  }
  
  /**
   * getLocalDirectoryTree
   * Sends a POST to /api/local/directory with { rootPath }
   * Expects a recursive JSON describing folder contents
   */
  export const getLocalDirectoryTree = async (rootPath: string): Promise<DirectoryResponse> => {
    try {
      console.log('Attempting to read directory:', rootPath);
      
      const response = await fetch('/api/local/directory', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ rootPath }),
      });
  
      // Get the response text first
      const responseText = await response.text();
      
      if (!response.ok) {
        console.error('Server response:', responseText);
        throw new Error(`Failed to read local directory: ${responseText}`);
      }
  
      // Try to parse the response as JSON
      try {
        const data = JSON.parse(responseText);
        
        // Validate the response structure
        if (!data || typeof data !== 'object' || !data.path) {
          throw new Error('Invalid directory response format');
        }
        
        return data;
      } catch (parseError) {
        console.error('Failed to parse server response:', responseText);
        throw new Error('Invalid JSON response from server');
      }
    } catch (error) {
      console.error('Error in getLocalDirectoryTree:', error);
      throw error;
    }
  };
  
  /**
   * readLocalFile
   * Sends a POST to /api/local/file with { filePath }
   * Returns file content as text
   */
  export const readLocalFile = async (filePath: string): Promise<string> => {
    try {
      const response = await fetch('/api/local/file', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filePath }),
      });

      if (!response.ok) {
        throw new Error(`Failed to read file: ${response.statusText}`);
      }

      const data = await response.json();
      return data.content;
    } catch (error) {
      console.error('Error reading local file:', error);
      throw error;
    }
  };
  
  const API_BASE_URL = 'http://localhost:3001/api';
  
  export const readLocalDirectory = async (rootPath: string) => {
    try {
      const response = await fetch('/api/local/directory', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ rootPath }),
      });

      if (!response.ok) {
        throw new Error(`Failed to read directory: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Error reading local directory:', error);
      throw error;
    }
  };
  
```

---

## File: src/services/FileService.ts

```typescript
// src/services/FileService.ts

import { FileNode, ApiResponse } from '../types';
import {
  getLocalDirectoryTree,
  readLocalFile,
} from './LocalFileService';

/**
 * Directories or subdirectories to ignore
 */
const STANDARD_DIRS = new Set([
  'node_modules', 'dist', 'build', '.git', '.idea', '.vscode',
  'coverage', 'vendor', '__pycache__', 'env', 'venv'
]);

/**
 * File extensions considered "text" for concatenation
 */
const TEXT_EXTENSIONS = new Set([
  '.txt', '.md', '.py', '.js', '.html', '.css', '.json', '.xml',
  '.yaml', '.yml', '.sh', '.bat', '.ps1', '.java', '.c', '.cpp',
  '.h', '.hpp', '.cs', '.php', '.rb', '.go', '.rs', '.ts', '.jsx',
  '.tsx', '.vue', '.scala', '.kt', '.groovy', '.gradle', '.sql',
  '.gitignore', '.env', '.cfg', '.ini', '.toml', '.csv'
]);

/**
 * Helper to decide if a given file is textual
 */
export const isTextFile = (filename: string): boolean => {
  if (filename === '.cursorrules') return true;
  const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
  return TEXT_EXTENSIONS.has(ext);
};

/**
 * Helper to skip "standard" directories
 */
export const isStandardLibraryPath = (path: string): boolean => {
  return Array.from(STANDARD_DIRS).some((dir) =>
    path.toLowerCase().includes(`/${dir.toLowerCase()}/`)
  );
};

/**
 * Map file extensions to syntax highlights (for the Markdown code fence)
 */
export const getLanguageFromExtension = (filename: string): string => {
  const ext = filename.substring(filename.lastIndexOf('.')).toLowerCase();
  const languageMap: Record<string, string> = {
    '.py': 'python',
    '.js': 'javascript',
    '.ts': 'typescript',
    '.tsx': 'typescript',
    '.jsx': 'javascript',
    '.html': 'html',
    '.css': 'css',
    '.java': 'java',
    '.cpp': 'cpp',
    '.c': 'c',
    '.rb': 'ruby',
    '.php': 'php',
    '.go': 'go',
    '.rs': 'rust',
    '.sql': 'sql',
  };
  return languageMap[ext] || 'text';
};

/**
 * getDirectoryTree
 * Recursively fetches a local directory tree, then converts it
 * into a FileNode structure, skipping standard directories.
 */
export const getDirectoryTree = async (rootPath: string): Promise<FileNode> => {
  try {
    // Sanitize the path input
    const normalizedPath = rootPath.trim();
    if (!normalizedPath) {
      throw new Error('Root path cannot be empty');
    }

    // Add logging for debugging
    console.log('Attempting to fetch directory tree for:', normalizedPath);
    
    const rawTree = await getLocalDirectoryTree(normalizedPath);
    
    // Add validation for the response
    if (!rawTree || typeof rawTree !== 'object') {
      throw new Error('Invalid directory tree response');
    }

    const buildTree = (entry: any): FileNode | null => {
      if (!entry || !entry.path) {
        return null;
      }

      // If it's a standard library path, skip it
      if (isStandardLibraryPath(entry.path)) {
        return null;
      }

      const node: FileNode = {
        path: entry.path,
        type: entry.type,
        children: [],
      };

      if (entry.type === 'directory' && entry.children) {
        for (const child of entry.children) {
          const childNode = buildTree(child);
          if (childNode) {
            node.children?.push(childNode);
          }
        }
      }
      return node;
    };

    const treeNode = buildTree(rawTree);
    if (!treeNode) {
      throw new Error('Root directory is excluded or invalid');
    }
    return treeNode;
  } catch (error) {
    console.error('Error in getDirectoryTree:', error);
    throw error;
  }
};

/**
 * concatenateFiles
 * For each selected path:
 *   - read local file
 *   - skip if not text or in standard library dir
 *   - append to a big markdown
 */
export const concatenateFiles = async (
  selectedPaths: string[],
  prNumber: string // currently unused in the local approach
): Promise<ApiResponse<string>> => {
  try {
    const timestamp = new Date().toISOString();
    let concatenated = `# Code Review Context\n\n`;
    concatenated += `Generated: ${timestamp}\n\n`;

    // Table of contents
    concatenated += `## Selected Files\n\n`;
    selectedPaths.forEach((path) => {
      concatenated += `- ${path}\n`;
    });
    concatenated += `\n---\n\n`;

    // Process each selected file
    for (const path of selectedPaths) {
      if (isStandardLibraryPath(path)) {
        continue;
      }
      // Example: skip non-text files
      const filename = path.split('/').pop() || '';
      if (!isTextFile(filename)) {
        continue;
      }

      try {
        // 1) Read the file content from local
        const fileContent = await readLocalFile(path);
        // 2) Derive language from file extension
        const language = getLanguageFromExtension(path);

        // 3) Append to concatenated markdown
        concatenated += `## File: ${path}\n\n`;
        concatenated += `\`\`\`${language}\n${fileContent}\n\`\`\`\n\n`;
        concatenated += `---\n\n`;
      } catch (error) {
        console.error(`Error processing file ${path}:`, error);
        concatenated += `## File: ${path}\n\n`;
        concatenated += `[Error reading file]\n\n---\n\n`;
      }
    }

    return {
      success: true,
      data: concatenated,
    };
  } catch (error) {
    console.error('Error concatenating files:', error);
    return {
      success: false,
      error: 'Failed to concatenate selected files',
    };
  }
};

```

---

## File: src/services/LLMService.ts

```typescript
import { ApiResponse } from '../types';
import { generateSystemPrompt } from '../prompts/systemPrompt';

interface ReviewRequest {
  jiraTicket: any;
  githubPR: any;
  concatenatedFiles: string;
  referenceFiles: string[];
  systemPrompt: string;
}

interface ReviewResponse {
  review: string;
  suggestions: string[];
  score: number;
}

interface CodeReviewParams {
  jiraTicket: any;
  githubPR: any;
  concatenatedFiles: string;
  referenceFiles: string[];
}

interface CodeReviewResponse {
  success: boolean;
  data?: string;
  error?: string;
}

const GEMINI_API_KEY = process.env.REACT_APP_GEMINI_API_KEY;
const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent";

export const generateCodeReview = async ({
  jiraTicket,
  githubPR,
  concatenatedFiles,
  referenceFiles
}: CodeReviewParams): Promise<CodeReviewResponse> => {
  try {
    const promptString = generateSystemPrompt({
      jiraTicket,
      githubPR,
      concatenatedFiles,
      additionalFiles: referenceFiles,
    });

    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: promptString
          }]
        }],
        generationConfig: {
          temperature: 0.3,
          topK: 40,
          topP: 0.8,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.statusText}`);
    }

    const result = await response.json();

    if (!result?.candidates?.[0]?.content?.parts?.[0]?.text) {
      throw new Error('Unexpected response format from Gemini API');
    }

    const generatedText = result.candidates[0].content.parts[0].text;

    if (!generatedText.includes('1. SUMMARY') || 
        !generatedText.includes('2. CRITICAL ISSUES')) {
      throw new Error('Generated review does not contain the required sections');
    }

    return {
      success: true,
      data: generatedText
    };
  } catch (error) {
    console.error('Error generating review:', error);
    return {
      success: false,
      error: error instanceof Error 
        ? error.message 
        : 'Failed to generate review'
    };
  }
};

```

---

